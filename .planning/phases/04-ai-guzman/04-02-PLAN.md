---
phase: 04-ai-guzman
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/handlers/game-loop.ts
  - src/lib/messages.ts
autonomous: true

must_haves:
  truths:
    - "Mission posting at 09:00 sends AI-generated narrative instead of static template"
    - "Result reveal at 21:00 sends AI-generated dramatic reveal instead of static template"
    - "Narrative context is updated after each round with mission theme and outcome"
    - "Story arc builds across rounds -- Round 3 narrative references Round 1-2 outcomes"
    - "When OpenAI fails mid-game, game continues with template fallback seamlessly"
    - "Guzman references specific player names in AI-generated messages"
  artifacts:
    - path: "src/handlers/game-loop.ts"
      provides: "Game loop with AI generation calls replacing static MESSAGES for missions and reveals"
      contains: "generateMissionNarrative"
    - path: "src/lib/messages.ts"
      provides: "Enhanced fallback templates with 3 variants for high-frequency messages"
      contains: "MISSION_POST_VARIANTS"
  key_links:
    - from: "src/handlers/game-loop.ts"
      to: "src/lib/ai-guzman.ts"
      via: "import and call generateMissionNarrative, generateResultReveal, updateNarrativeContext"
      pattern: "generateMissionNarrative|generateResultReveal|updateNarrativeContext"
    - from: "src/lib/ai-guzman.ts"
      to: "src/lib/messages.ts"
      via: "fallback to MESSAGES templates on failure"
      pattern: "MESSAGES\\."
---

<objective>
Replace static template messages with AI-generated content for mission posting and result reveals in the game loop.

Purpose: This is where Guzman comes alive. The 09:00 mission post becomes a unique dramatic narrative with characters, setting, and stakes. The 21:00 result reveal becomes a theatrical buildup with tension and suspense. Both maintain template fallback for reliability. The narrative context accumulates so each round builds on the previous story.

Output: Modified game-loop.ts with AI generation calls, enhanced fallback templates in messages.ts
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-ai-guzman/04-CONTEXT.md
@.planning/phases/04-ai-guzman/04-RESEARCH.md
@.planning/phases/04-ai-guzman/04-01-SUMMARY.md
@src/handlers/game-loop.ts
@src/lib/messages.ts
@src/lib/ai-guzman.ts
@src/lib/ai-prompts.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate AI mission narratives and result reveals into game-loop.ts</name>
  <files>src/handlers/game-loop.ts</files>
  <action>
Import from ai-guzman.ts at the top of game-loop.ts:
```typescript
import {
  generateMissionNarrative,
  generateResultReveal,
  updateNarrativeContext,
  getGuzmanContext,
} from "../lib/ai-guzman.js";
```

**Mission posting (handleMissionPost, ~line 1413):** Replace the static `MESSAGES.MISSION_POST(round.round_number)` call. Before sending:
1. Get player names from `getGamePlayersOrderedWithInfo(game.id)` (already queried nearby -- reuse)
2. Get `guzmanContext` via `getGuzmanContext(game.id)`
3. Call `const missionText = await generateMissionNarrative(round.round_number, guzmanContext, playerNames)`
4. Send missionText via queue.send (same parse_mode: "HTML")
The fallback is built into generateMissionNarrative -- no additional try/catch needed here.

**Result reveal (resolveExecution helper, ~lines 520-590):** This is the shared function called by both the 21:00 scheduler and early resolution. Replace the static reveal sequence:
1. Before the suspense/result messages, get guzmanContext
2. Determine missionResult and golaCount (already computed in the function)
3. Get playerNames and teamNames from existing variables
4. Send SUSPENSE_1 message first (the existing short atmospheric template), then wait the existing sleep delay
5. Call `const revealText = await generateResultReveal(round.round_number, guzmanContext, missionResult, golaCount, playerNames, teamNames)`
6. Send revealText as the result message (replacing the separate MISSION_SUCCESS/MISSION_FAIL template). This approach works consistently for both AI and fallback paths -- SUSPENSE_1 provides the dramatic pause, then the AI-generated (or fallback template) reveal follows.

7. After the result is determined (success/fail/kaos_fail), call `await updateNarrativeContext(game.id, round.round_number, missionTheme, outcome, narrativeBeats)` where:
   - missionTheme: extract from AI response or use "St칬t {roundNumber}" as default
   - outcome: the computed missionResult
   - narrativeBeats: brief summary of what happened ("Team lyckades" / "2 golade" / "Kaos-fail efter 3 nej")

**Score update and round end messages:** Keep these as templates -- they're factual (scores, round numbers) and don't benefit from AI generation. This is per research recommendation: "Some messages should stay as templates."

**Win condition messages (GAME_WON_LIGAN, GAME_WON_AINA):** Keep as templates for now -- they trigger Sista Chansen and need to be reliable. The drama comes from the AI result reveal that precedes them.

**Sista Chansen and Final Reveal messages:** Keep as templates -- these are endgame-critical paths where reliability matters most.

Do NOT modify: vote tally, vote reveal, nomination prompts, execution prompts, reminder messages, Sista Chansen messages, or any callback handler logic. Only mission narratives and result reveals get AI treatment in this plan.
  </action>
  <verify>
`npx tsc --noEmit` passes. `grep "generateMissionNarrative\|generateResultReveal\|updateNarrativeContext" src/handlers/game-loop.ts` shows the AI function calls are present. `grep "MESSAGES.MISSION_POST" src/handlers/game-loop.ts` should still appear (in the fallback path inside ai-guzman.ts, not directly in game-loop.ts -- verify it's been replaced in game-loop.ts with the AI call).
  </verify>
  <done>Mission posting calls generateMissionNarrative instead of MESSAGES.MISSION_POST. Result reveal calls generateResultReveal for dramatic AI-driven reveals. Narrative context is updated after each round. Fallback to templates is seamless when AI fails.</done>
</task>

<task type="auto">
  <name>Task 2: Enrich fallback templates with variants for graceful degradation</name>
  <files>src/lib/messages.ts</files>
  <action>
Add 3 variants each for the two high-frequency AI-replaced message types, plus a "lazy Guzman" fallback prefix. These are used when AI falls back to templates mid-game so the experience doesn't feel repetitive or jarring.

1. Add a `FALLBACK_PREFIX` array with 3 in-character acknowledgments that AI is unavailable (per locked decision: "Orka snacka idag..."):
```typescript
FALLBACK_PREFIX: [
  "Orka snacka idag bre... ",
  "Guzman har huvudv칛rk, shuno... ",
  "Kort och gott idag mannen... ",
] as const,
```

2. Convert MISSION_POST to support variants. Keep the existing function as-is (backwards compatible) but add:
```typescript
MISSION_POST_VARIANTS: [
  (roundNumber: number) => `<b>Runda ${roundNumber} -- ny st칬t!</b> 游꿢\n\n...`,
  (roundNumber: number) => `<b>St칬t nummer ${roundNumber}, bre.</b> 游댠\n\n...`,
  (roundNumber: number) => `<b>Ligan! Runda ${roundNumber}.</b> 游꿢\n\n...`,  // Original
] as const,
```
Each variant should be in Guzman's voice, use proper 친칛칬, and vary the opening/tone while conveying the same information: it's a new round, Capo picks team, group votes. Keep them shorter than AI narratives (~100-150 chars) -- these are "lazy Guzman" fallbacks.

3. Add MISSION_RESULT_VARIANTS similarly for both success and fail:
```typescript
MISSION_SUCCESS_VARIANTS: [
  "<b>St칬ten lyckades!</b> 九\n\nAlla var lojala -- eller s친 var Golare f칬r fega att agera. Ligan tar po칛ngen! 游눯",
  "<b>Clean!</b> 九\n\nIngen golade. Familjen h친ller ihop, bre. Po칛ngen 칛r v친r. 游눯",
  "<b>Lyckad st칬t!</b> 九\n\nBra jobbat. Inga r친ttor den h칛r g친ngen... eller? 游뱂",
] as const,

MISSION_FAIL_VARIANTS: [
  (golaCount: number) => `<b>St칬ten misslyckades!</b> 仇\n\n${golaCount} golade. R친ttor bland oss, bre. 游`,
  (golaCount: number) => `<b>Saboterat!</b> 仇\n\n${golaCount} ${golaCount === 1 ? "person" : "personer"} s친lde oss. Aina tar po칛ngen. 游`,
  (golaCount: number) => `<b>Vi 친kte dit!</b> 仇\n\nN친gon golade -- ${golaCount} stycken. Familjen bl칬der, bre. 游`,
] as const,
```

4. Export a helper function `getRandomVariant<T>(variants: readonly T[]): T` that picks a random variant using `Math.floor(Math.random() * variants.length)`.

All Swedish text MUST use proper 친칛칬 characters. Never substitute with a/a/o.
  </action>
  <verify>
`npx tsc --noEmit` passes. `grep "FALLBACK_PREFIX\|MISSION_POST_VARIANTS\|getRandomVariant" src/lib/messages.ts` shows all new additions. Verify all Swedish text uses proper 친칛칬 (no "a" where "친" or "칛" should be).
  </verify>
  <done>3 variants each for mission post, mission success, and mission fail templates. Lazy Guzman fallback prefixes. getRandomVariant helper for variety in fallback mode. All text uses proper Swedish 친칛칬 characters.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- full project compiles
2. game-loop.ts imports and calls AI generation functions for mission posting and result reveals
3. MESSAGES.MISSION_POST is no longer called directly in game-loop.ts (replaced by generateMissionNarrative)
4. Narrative context is updated after each round result
5. Fallback templates have 3 variants each for variety
6. All Swedish text uses proper 친칛칬 characters
</verification>

<success_criteria>
- 09:00 mission post produces AI-generated narrative when OpenAI is available
- 21:00 result reveal produces AI-generated dramatic reveal when OpenAI is available
- Both fall back seamlessly to (enriched) templates on any AI failure
- Narrative context accumulates across rounds for story continuity
- Guzman references specific player names in AI messages
- Game loop still functions identically when OPENAI_API_KEY is not set
</success_criteria>

<output>
After completion, create `.planning/phases/04-ai-guzman/04-02-SUMMARY.md`
</output>
