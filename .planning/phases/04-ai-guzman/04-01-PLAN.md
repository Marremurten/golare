---
phase: 04-ai-guzman
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/ai-client.ts
  - src/lib/ai-prompts.ts
  - src/lib/ai-guzman.ts
  - src/config.ts
  - src/db/schema.sql
  - src/db/types.ts
  - src/db/client.ts
  - package.json
autonomous: true
user_setup:
  - service: openai
    why: "AI-generated game master messages"
    env_vars:
      - name: OPENAI_API_KEY
        source: "OpenAI Dashboard -> API keys (https://platform.openai.com/api-keys)"

must_haves:
  truths:
    - "OpenAI client connects and generates text when API key is valid"
    - "Every AI generation function falls back to existing MESSAGES template on any failure"
    - "Guzman system prompt produces Swedish orten suburb slang output"
    - "Game narrative context persists in guzman_context JSONB column across rounds"
    - "AI output is sanitized for Telegram HTML before sending"
  artifacts:
    - path: "src/lib/ai-client.ts"
      provides: "OpenAI client singleton with tiered model selection"
      exports: ["getAIClient", "MODEL_MAP"]
    - path: "src/lib/ai-prompts.ts"
      provides: "Guzman system prompt and prompt builders for each message type"
      exports: ["buildGuzmanSystemPrompt", "buildMissionPrompt", "buildResultPrompt", "buildWhisperPrompt", "buildGapFillPrompt"]
    - path: "src/lib/ai-guzman.ts"
      provides: "AI generation functions with template fallback for every game event"
      exports: ["generateMissionNarrative", "generateResultReveal", "generateWhisperMessage", "generateGapFillComment", "updateNarrativeContext", "getGuzmanContext", "sanitizeForTelegram"]
    - path: "src/db/schema.sql"
      provides: "guzman_context JSONB column on games, whispers table"
      contains: "guzman_context"
    - path: "src/config.ts"
      provides: "OPENAI_API_KEY config entry"
      contains: "OPENAI_API_KEY"
  key_links:
    - from: "src/lib/ai-guzman.ts"
      to: "src/lib/ai-client.ts"
      via: "getAIClient() import"
      pattern: "getAIClient"
    - from: "src/lib/ai-guzman.ts"
      to: "src/lib/messages.ts"
      via: "MESSAGES fallback on catch"
      pattern: "catch.*MESSAGES"
    - from: "src/lib/ai-guzman.ts"
      to: "src/lib/ai-prompts.ts"
      via: "prompt builder imports"
      pattern: "buildGuzmanSystemPrompt|buildMissionPrompt"
    - from: "src/lib/ai-guzman.ts"
      to: "src/db/client.ts"
      via: "getGuzmanContext/updateGuzmanContext DB calls"
      pattern: "getGuzmanContext|updateGuzmanContext"
---

<objective>
OpenAI integration foundation: client, prompts, AI generation module with template fallbacks, DB schema for narrative context and whispers.

Purpose: Creates the entire AI infrastructure that Plans 02 and 03 will consume. Every AI generation function wraps OpenAI in try/catch with fallback to existing MESSAGES templates, ensuring the game never blocks on API failure. The Guzman system prompt encodes the full orten suburb slang persona.

Output: ai-client.ts, ai-prompts.ts, ai-guzman.ts modules + DB migrations + config updates + npm dependencies
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-ai-guzman/04-CONTEXT.md
@.planning/phases/04-ai-guzman/04-RESEARCH.md
@src/lib/messages.ts
@src/config.ts
@src/db/schema.sql
@src/db/types.ts
@src/db/client.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies, config, and OpenAI client singleton</name>
  <files>package.json, src/config.ts, src/lib/ai-client.ts</files>
  <action>
1. Run `npm install openai zod` to add OpenAI SDK v6.x and Zod.

2. In `src/config.ts`, add OPENAI_API_KEY as an OPTIONAL env var (game must work without it). Add it after the existing config entries:
```typescript
OPENAI_API_KEY: process.env.OPENAI_API_KEY || null,
```
Do NOT use requireEnv -- the key is optional so the game can run with template fallbacks only.

3. Create `src/lib/ai-client.ts`:
- Import OpenAI from "openai" and config from "../config.js"
- Create a lazy singleton: `let client: OpenAI | null = null`
- Export `getAIClient(): OpenAI | null` -- returns null if OPENAI_API_KEY is not set. If set, creates client with `timeout: 10_000` and `maxRetries: 1`
- Export `MODEL_MAP` record mapping message tiers to models:
  - `narrative: "gpt-4o-mini"` (missions, reveals -- need quality)
  - `commentary: "gpt-4.1-nano"` (gap-fill, reactions -- speed + cheapness)
  - `whisper: "gpt-4o-mini"` (manipulation needs subtlety)
- Export `type MessageTier = "narrative" | "commentary" | "whisper"`
- Log `[ai-client] OpenAI client initialized` on first creation, or `[ai-client] No OPENAI_API_KEY -- AI features disabled, using templates` if key is missing
  </action>
  <verify>
`npx tsc --noEmit` passes. `grep "openai" package.json` shows the dependency. `grep "OPENAI_API_KEY" src/config.ts` shows the optional config entry.
  </verify>
  <done>OpenAI SDK installed, config accepts optional API key, client singleton returns null when key is missing (graceful degradation).</done>
</task>

<task type="auto">
  <name>Task 2: DB schema migration, types, and CRUD for narrative context + whispers</name>
  <files>src/db/schema.sql, src/db/types.ts, src/db/client.ts</files>
  <action>
1. In `src/db/schema.sql`, append two new statements:

```sql
-- AI Guzman narrative context (Phase 4)
ALTER TABLE games ADD COLUMN IF NOT EXISTS guzman_context JSONB DEFAULT '{}';

-- Whispers table: tracks all Guzman DM whispers to players
CREATE TABLE IF NOT EXISTS whispers (
  id               UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  game_id          UUID NOT NULL REFERENCES games(id) ON DELETE CASCADE,
  round_number     INT NOT NULL,
  target_player_id UUID NOT NULL REFERENCES game_players(id),
  message          TEXT NOT NULL,
  truth_level      TEXT NOT NULL DEFAULT 'truth',
  trigger_type     TEXT NOT NULL DEFAULT 'scheduled',
  sent_at          TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT valid_truth_level CHECK (truth_level IN ('truth', 'half_truth', 'lie')),
  CONSTRAINT valid_trigger_type CHECK (trigger_type IN ('scheduled', 'event'))
);

CREATE INDEX IF NOT EXISTS idx_whispers_game_id ON whispers (game_id);
CREATE INDEX IF NOT EXISTS idx_whispers_target_player ON whispers (target_player_id);
```

2. In `src/db/types.ts`:
- Add `guzman_context: Record<string, unknown>` to the `Game` type (after `team_size`)
- Add the Game.Update type should include guzman_context in its Partial<Game> (already covered since Update is Partial<Game>)
- Add `GuzmanContext` type alias:
```typescript
export type GuzmanContext = {
  storyArc: string;
  roundSummaries: Array<{
    round: number;
    missionTheme: string;
    outcome: "success" | "fail" | "kaos_fail";
    narrativeBeats: string;
  }>;
  playerNotes: Record<string, string>;
  mood: string;
};
```
- Add `TruthLevel = "truth" | "half_truth" | "lie"` type
- Add `WhisperTrigger = "scheduled" | "event"` type
- Add `Whisper` type:
```typescript
export type Whisper = {
  id: string;
  game_id: string;
  round_number: number;
  target_player_id: string;
  message: string;
  truth_level: TruthLevel;
  trigger_type: WhisperTrigger;
  sent_at: string;
};
```
- Add `WhisperInsert = Omit<Whisper, "id" | "sent_at">` type
- Add the whispers table to the Database type definition following the existing pattern

3. In `src/db/client.ts`, add three new functions:
- `getGuzmanContext(gameId: string): Promise<GuzmanContext>` -- select guzman_context from games where id=gameId, return parsed or default empty context `{ storyArc: "", roundSummaries: [], playerNotes: {}, mood: "paranoid" }`
- `updateGuzmanContext(gameId: string, context: GuzmanContext): Promise<void>` -- update games set guzman_context=context where id=gameId
- `createWhisper(whisper: WhisperInsert): Promise<Whisper>` -- insert into whispers, return the row
- `getWhispersForGame(gameId: string): Promise<Whisper[]>` -- select from whispers where game_id=gameId ordered by sent_at
- `getWhispersForPlayerInRound(gameId: string, targetPlayerId: string, roundNumber: number): Promise<Whisper[]>` -- for preventing duplicate whispers to same player in same round
  </action>
  <verify>
`npx tsc --noEmit` passes. The new types and CRUD functions compile without errors.
  </verify>
  <done>DB schema has guzman_context JSONB column on games and whispers table. TypeScript types for GuzmanContext and Whisper exist. Five new CRUD functions for reading/writing narrative context and whispers.</done>
</task>

<task type="auto">
  <name>Task 3: Guzman system prompt, prompt builders, and AI generation module with fallbacks</name>
  <files>src/lib/ai-prompts.ts, src/lib/ai-guzman.ts</files>
  <action>
1. Create `src/lib/ai-prompts.ts` with the Guzman persona and prompt builders:

**buildGuzmanSystemPrompt()** -- Returns the core Guzman persona system prompt. MUST use proper Swedish characters (åäö). Key elements per user decisions:
- Full orten suburb slang: bre, shuno, wallah, yalla, mannen, bror, para, beckna, guss, aina
- Paranoid criminal leader personality, both paranoia-stirring AND playing favorites
- Drops hints making everyone suspect each other, publicly praises/mocks specific players
- Occasionally breaks the fourth wall with light meta-humor
- Dramatic and theatrical -- everything is life and death
- HTML formatting only (<b>, <i>), never markdown
- Keep text under ~2000 chars for Telegram
- Always reference players by name
- Consistent base personality per game, mood shifts based on events (per discretion decision)

Include 2-3 few-shot example outputs in the system prompt showing the desired register, slang level, and formatting. Examples should demonstrate:
- Mission narrative style (multi-paragraph, story-driven)
- Result reveal style (suspense, teasing, dramatic)
- Whisper style (manipulative, ambiguous)

**buildMissionPrompt(roundNumber, gameContext, playerNames)** -- Builds the user message for mission narrative generation. Include: round number, story arc so far (from gameContext.roundSummaries), player names, current mood. Instruct: create a unique dramatic mission briefing, reference the ongoing story, name specific players. Max ~500 tokens.

**buildResultPrompt(roundNumber, gameContext, missionResult, golaCount, playerNames, teamNames)** -- Builds prompt for result reveal. Include: what happened (success/fail/kaos_fail), how many golade, who was on the team, story context. Instruct: dramatic buildup, tease before revealing, reference specific players.

**buildWhisperPrompt(gameContext, targetPlayerName, otherPlayerNames, roundEvents)** -- Builds prompt for whisper generation. CRITICAL: NEVER include actual role assignments in the prompt. Only include observable information: voting patterns, team selections, mission results. Instruct: generate a manipulative DM mixing truth/lies, role-adjacent hints only, never explicit reveals. Mention the target player by name.

**buildGapFillPrompt(gameContext, recentActivity, playerNames)** -- Builds prompt for gap-fill commentary. Include: what's happening (or not happening -- silence), who's active/quiet, game tension level. Instruct: short reactive comment (1-3 sentences), stir drama.

2. Create `src/lib/ai-guzman.ts` -- the core AI generation module:

**sanitizeForTelegram(text: string): string** -- Strip all HTML tags except <b>, <i>, <code>, <a>. Use regex: replace `<(?!\/?(?:b|i|code|a)\b)[^>]+>` with empty string. Also truncate to 4000 chars (leave room for Telegram's 4096 limit) with "..." suffix if truncated.

**generateMissionNarrative(roundNumber, gameContext, playerNames): Promise<string>** -- Uses "narrative" tier model. Calls OpenAI with system + user prompt. On success: sanitize output, update guzman_context with new round's missionTheme. On ANY failure (no client, API error, empty response, timeout): `console.warn("[ai-guzman] Mission narrative failed, using template:", err)` and return `MESSAGES.MISSION_POST(roundNumber)`. The in-character fallback acknowledgment ("Orka snacka idag bre...") should prefix the template when AI was available before but just failed (check if guzman_context has prior round summaries).

**generateResultReveal(roundNumber, gameContext, missionResult, golaCount, playerNames, teamNames): Promise<string>** -- Uses "narrative" tier. Dramatic reveal text. On failure: return appropriate `MESSAGES.MISSION_SUCCESS` or `MESSAGES.MISSION_FAIL(golaCount)`.

**generateWhisperMessage(gameContext, targetPlayerName, otherPlayerNames, roundEvents): Promise<{ message: string; truthLevel: TruthLevel } | null>** -- Uses "whisper" tier with `zodResponseFormat` for structured output (WhisperSchema with message + truthLevel fields). On failure: return null (whispers are disabled during fallback per discretion decision). NEVER include role in the OpenAI prompt -- only behavioral data. Note: no `targetRole` parameter exists because the AI must never have access to role information.

**generateGapFillComment(gameContext, recentActivity, playerNames): Promise<string | null>** -- Uses "commentary" tier. On failure: return null (skip the comment silently).

**updateNarrativeContext(gameId, roundNumber, missionTheme, outcome, narrativeBeats): Promise<void>** -- Read current guzman_context, append round summary, update mood based on outcome (losses make Guzman angrier, wins make him cocky), compress older round summaries if total context is getting long (keep last 2 rounds detailed, older ones as 1-sentence summaries). Write back to DB.

**getGuzmanContext(gameId): Promise<GuzmanContext>** -- Thin wrapper around db client's getGuzmanContext.

All functions must: (a) check if getAIClient() returns null first and immediately fall back, (b) wrap OpenAI calls in try/catch, (c) sanitize output before returning, (d) log warnings on fallback with `[ai-guzman]` prefix.
  </action>
  <verify>
`npx tsc --noEmit` passes. All exported functions exist and have correct signatures. `grep -c "catch" src/lib/ai-guzman.ts` shows every generation function has error handling. `grep "MESSAGES\." src/lib/ai-guzman.ts` shows fallback references to existing templates.
  </verify>
  <done>Complete AI generation module with 5 generation functions, each wrapping OpenAI with template fallback. Guzman system prompt encodes full orten persona with few-shot examples. Prompt builders for all message types. HTML sanitization. Narrative context accumulation across rounds.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- full project compiles with no errors
2. `grep "openai" package.json` -- dependency installed
3. `grep "OPENAI_API_KEY" src/config.ts` -- config entry exists
4. Every function in ai-guzman.ts has a try/catch with MESSAGES.* fallback
5. System prompt in ai-prompts.ts uses proper Swedish åäö characters throughout
6. No function in ai-guzman.ts blocks without a timeout/fallback path
</verification>

<success_criteria>
- OpenAI client singleton works with optional API key (null when missing)
- All 5 AI generation functions exist with template fallback on any failure
- Guzman system prompt produces authentic orten Swedish suburb slang
- DB schema supports guzman_context JSONB and whispers table
- Narrative context accumulates across rounds for story arc continuity
- HTML sanitization strips non-Telegram-safe tags
- Game runs normally with templates when OPENAI_API_KEY is not set
</success_criteria>

<output>
After completion, create `.planning/phases/04-ai-guzman/04-01-SUMMARY.md`
</output>
