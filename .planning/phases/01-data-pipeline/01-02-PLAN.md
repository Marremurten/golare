---
phase: 01-data-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/message-capture.ts
  - src/bot.ts
  - src/handlers/lobby.ts
  - src/handlers/game-loop.ts
  - src/handlers/game-commands.ts
autonomous: true

must_haves:
  truths:
    - "Player text messages in group chat are captured and stored via fire-and-forget middleware (DATA-01)"
    - "Bot messages, commands, non-player messages, and DM messages are filtered out before storage (DATA-03)"
    - "Bot admin status is checked at game creation and blocks /nyttspel if not admin (DATA-04)"
    - "Game ID cache is invalidated when games start, finish, or get cancelled"
    - "Message capture never blocks the grammY middleware chain"
  artifacts:
    - path: "src/lib/message-capture.ts"
      provides: "capturePlayerMessage function with filtering and caching, invalidateGameCache export"
      exports: ["capturePlayerMessage", "invalidateGameCache"]
      min_lines: 40
    - path: "src/bot.ts"
      provides: "Fire-and-forget capturePlayerMessage call in existing message:text middleware"
      contains: "capturePlayerMessage"
    - path: "src/handlers/lobby.ts"
      provides: "Bot admin check in /nyttspel command, cache invalidation on game start"
      contains: "isBotAdmin"
    - path: "src/handlers/game-loop.ts"
      provides: "Cache invalidation on game finish"
      contains: "invalidateGameCache"
    - path: "src/handlers/game-commands.ts"
      provides: "Cache invalidation on game cancel"
      contains: "invalidateGameCache"
  key_links:
    - from: "src/bot.ts"
      to: "src/lib/message-capture.ts"
      via: "import capturePlayerMessage, fire-and-forget call"
      pattern: "capturePlayerMessage\\(ctx\\)\\.catch"
    - from: "src/lib/message-capture.ts"
      to: "src/db/client.ts"
      via: "import getActiveGame, getGamePlayerByTelegramId, createPlayerMessage"
      pattern: "import.*from.*db/client"
    - from: "src/handlers/lobby.ts"
      to: "src/lib/message-capture.ts"
      via: "import invalidateGameCache"
      pattern: "invalidateGameCache"
    - from: "src/handlers/game-loop.ts"
      to: "src/lib/message-capture.ts"
      via: "import invalidateGameCache"
      pattern: "invalidateGameCache"
    - from: "src/handlers/game-commands.ts"
      to: "src/lib/message-capture.ts"
      via: "import invalidateGameCache"
      pattern: "invalidateGameCache"
---

<objective>
Create the message capture module and wire it into the bot middleware, lobby handler, and game state transitions.

Purpose: This completes the data pipeline by connecting the data layer (Plan 01) to the live bot. Player group messages flow through filtering logic into the database, the bot validates its own admin status before allowing game creation, and the game ID cache stays fresh across state transitions.
Output: New `message-capture.ts` module, modified `bot.ts`, `lobby.ts`, `game-loop.ts`, and `game-commands.ts`.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-data-pipeline/01-RESEARCH.md
@.planning/phases/01-data-pipeline/01-01-SUMMARY.md
@src/bot.ts
@src/handlers/lobby.ts
@src/handlers/game-loop.ts
@src/handlers/game-commands.ts
@src/db/client.ts
@src/lib/messages.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create message capture module with filtering and caching</name>
  <files>src/lib/message-capture.ts</files>
  <action>
Create new file `src/lib/message-capture.ts` with:

1. **Imports:**
   - `type { Context } from "grammy"`
   - `getActiveGame`, `getGamePlayerByTelegramId`, `createPlayerMessage` from `"../db/client.js"`

2. **In-memory game ID cache** (same pattern as `groupActivity` Map in whisper-handler.ts):
   ```typescript
   const gameIdCache = new Map<number, { gameId: string; cachedAt: number }>();
   const CACHE_TTL_MS = 5 * 60 * 1000; // 5 minutes
   ```

3. **`invalidateGameCache(groupChatId: number): void`** -- exported function that deletes a cache entry. Add JSDoc: "Call when game state changes (start, finish, cancel)."

4. **`capturePlayerMessage(ctx: Context): Promise<void>`** -- exported async function. The core capture logic with DATA-03 filtering:

   a. **Guard clauses (filtering -- DATA-03):**
      - Return early if `!ctx.from` or `!ctx.message?.text`
      - Return early if `ctx.from.is_bot` (filter bot messages)
      - Return early if `ctx.message.text.startsWith("/")` (filter commands)

   b. **Extract data:**
      - `groupChatId = ctx.chat!.id`
      - `text = ctx.message.text.slice(0, 500)` (truncate to 500 chars for safety)

   c. **Resolve game_id from cache:**
      - Check `gameIdCache.get(groupChatId)` -- if cached and within TTL, use cached gameId
      - Otherwise, call `getActiveGame(groupChatId)` -- if game exists and `game.state !== "finished" && game.state !== "cancelled"`, cache it and use it
      - If no active game found, delete cache entry and return early

   d. **Resolve game_player_id:**
      - Call `getGamePlayerByTelegramId(gameId, ctx.from.id)`
      - If null (not a game player / spectator), return early

   e. **Store message:**
      - Call `createPlayerMessage({ game_id: gameId, game_player_id: gamePlayer.id, message_text: text })`

   The function must NEVER throw -- it is called fire-and-forget. However, it can throw internally and the `.catch()` in bot.ts will handle it. The function itself does NOT wrap in try/catch -- let errors propagate to the caller's `.catch()`.

5. Add clear JSDoc comments on both exported functions explaining their purpose and the fire-and-forget pattern.
  </action>
  <verify>Run `npx tsc --noEmit` to confirm TypeScript compilation passes. Verify the file exports both `capturePlayerMessage` and `invalidateGameCache`.</verify>
  <done>message-capture.ts exists with capturePlayerMessage (filtering + caching + storage) and invalidateGameCache, TypeScript compiles.</done>
</task>

<task type="auto">
  <name>Task 2: Wire middleware, bot admin check, and cache invalidation</name>
  <files>src/bot.ts, src/handlers/lobby.ts, src/handlers/game-loop.ts, src/handlers/game-commands.ts</files>
  <action>
**In `src/bot.ts`:**

1. Add import at top: `import { capturePlayerMessage } from "./lib/message-capture.js";`

2. Modify the existing middleware at line 37-42 (the `bot.on("message:text")` block). Add the fire-and-forget `capturePlayerMessage` call INSIDE the existing `if (ctx.chat?.type === "group" || ctx.chat?.type === "supergroup")` block, AFTER the existing `trackGroupMessage(ctx.chat.id)` call:
   ```typescript
   // Fire-and-forget: capture message for behavioral tracking (v1.1)
   capturePlayerMessage(ctx).catch((err) =>
     console.warn("[capture] Message capture failed:", err)
   );
   ```
   Keep the existing `trackGroupMessage(ctx.chat.id)` call intact. Keep `await next()` at the end. The middleware body should now be: trackGroupMessage, capturePlayerMessage (fire-and-forget), then next().

**In `src/handlers/lobby.ts`:**

1. Add import: `import { invalidateGameCache } from "../lib/message-capture.js";`

2. Add a helper function `isBotAdmin` (similar to the existing `isGroupAdmin` but checks the bot's own status):
   ```typescript
   async function isBotAdmin(ctx: Context, chatId: number): Promise<boolean> {
     try {
       const botMember = await ctx.api.getChatMember(chatId, ctx.me.id);
       return botMember.status === "administrator" || botMember.status === "creator";
     } catch {
       return false;
     }
   }
   ```

3. In the `/nyttspel` command handler, AFTER the existing admin check (step 1) and BEFORE the "check no active game" (step 2), add the bot admin check:
   ```typescript
   // 1b. Check bot is admin (required for message visibility -- DATA-04)
   const botAdmin = await isBotAdmin(ctx, ctx.chat.id);
   if (!botAdmin) {
     await ctx.reply(
       "Yo, jag beh√∂ver vara admin i gruppen f√∂r att kunna " +
       "se alla meddelanden. G√∂r mig till admin f√∂rst, sen k√∂r vi. üîß"
     );
     return;
   }
   ```
   **CRITICAL**: Use proper Swedish characters (beh√∂ver, f√∂r, G√∂r). Never use `o` for `√∂`.

4. In the start callback (`start:{gameId}`), AFTER `updateGame(gameId, { state: "active", ... })` (step 5, around line 329), add cache invalidation:
   ```typescript
   // Invalidate message capture cache (new game started)
   invalidateGameCache(game.group_chat_id);
   ```

**In `src/handlers/game-loop.ts`:**

1. Add import: `import { invalidateGameCache } from "../lib/message-capture.js";`

2. Find the two places where game state is set to `"finished"` (around lines 513 and 659). AFTER each `updateGame(game.id, { state: "finished" })` call, add:
   ```typescript
   invalidateGameCache(game.group_chat_id);
   ```

**In `src/handlers/game-commands.ts`:**

1. Add import: `import { invalidateGameCache } from "../lib/message-capture.js";`

2. Find where game state is set to `"cancelled"` (line 44). AFTER `await updateGame(game.id, { state: "cancelled" })`, add:
   ```typescript
   invalidateGameCache(game.group_chat_id);
   ```
  </action>
  <verify>
1. Run `npx tsc --noEmit` to confirm TypeScript compilation passes with zero errors.
2. Grep for `capturePlayerMessage` in bot.ts to confirm it is wired in the middleware.
3. Grep for `isBotAdmin` in lobby.ts to confirm the bot admin check exists.
4. Grep for `invalidateGameCache` across all modified files to confirm cache invalidation at all state transition points (lobby.ts game start, game-loop.ts game finish x2, game-commands.ts game cancel).
5. Verify the Swedish text in the bot admin warning uses proper characters (√∂, √∂, √∂ in beh√∂ver/f√∂r/G√∂r).
  </verify>
  <done>
- bot.ts fires capturePlayerMessage in existing middleware (fire-and-forget, non-blocking)
- lobby.ts blocks /nyttspel if bot is not admin (DATA-04) with proper Swedish warning message
- lobby.ts invalidates game cache on game start
- game-loop.ts invalidates game cache on game finish (both code paths)
- game-commands.ts invalidates game cache on game cancel
- TypeScript compiles cleanly
- Zero new dependencies (CONST-01)
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes (TypeScript compiles)
- `src/lib/message-capture.ts` exists and exports capturePlayerMessage + invalidateGameCache
- bot.ts calls capturePlayerMessage fire-and-forget inside group message middleware
- lobby.ts checks bot admin status before allowing /nyttspel (DATA-04)
- Cache invalidation is present at all 4 game state transition points
- All Swedish text uses proper characters (no substitutions)
- Zero new npm dependencies (CONST-01)
- Message filtering covers: bot messages, commands, non-players, no active game (DATA-03)
</verification>

<success_criteria>
- DATA-01: Player text messages from group chat are captured via middleware extension
- DATA-02: Storage uses dedicated table with ring buffer (Plan 01) -- wired here via createPlayerMessage
- DATA-03: Bot messages, commands, non-players, and no-active-game cases are filtered out
- DATA-04: Bot admin status is verified at game creation, hard-blocks if not admin
- CONST-01: Zero new npm dependencies
- The entire pipeline is fire-and-forget: message capture never blocks the handler chain
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-pipeline/01-02-SUMMARY.md`
</output>
