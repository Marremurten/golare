---
phase: 01-data-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema.sql
  - src/db/types.ts
  - src/db/client.ts
autonomous: true

must_haves:
  truths:
    - "player_messages table exists in PostgreSQL with ring buffer pruning trigger"
    - "TypeScript types for PlayerMessage and PlayerMessageInsert are exported from types.ts"
    - "CRUD functions createPlayerMessage, getRecentPlayerMessages, getAllRecentMessages are exported from client.ts"
    - "Database type definition includes player_messages table mapping"
  artifacts:
    - path: "src/db/schema.sql"
      provides: "player_messages table + prune trigger + index"
      contains: "CREATE TABLE IF NOT EXISTS player_messages"
    - path: "src/db/types.ts"
      provides: "PlayerMessage and PlayerMessageInsert types + Database table mapping"
      exports: ["PlayerMessage", "PlayerMessageInsert"]
    - path: "src/db/client.ts"
      provides: "CRUD functions for player_messages"
      exports: ["createPlayerMessage", "getRecentPlayerMessages", "getAllRecentMessages"]
  key_links:
    - from: "src/db/client.ts"
      to: "src/db/types.ts"
      via: "import PlayerMessage, PlayerMessageInsert"
      pattern: "import.*PlayerMessage.*from.*types"
    - from: "src/db/client.ts"
      to: "supabase.from('player_messages')"
      via: "Supabase client queries"
      pattern: "from\\(\"player_messages\"\\)"
---

<objective>
Create the player_messages data layer: database table with ring buffer pruning, TypeScript types, and CRUD functions.

Purpose: Establishes the storage foundation for capturing player group messages. The ring buffer (last ~10 messages per player per game) keeps data bounded while providing enough context for behavioral analysis in Phase 2. No application logic yet -- just the data layer.
Output: Extended schema.sql, types.ts, and client.ts with player_messages support.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-data-pipeline/01-RESEARCH.md
@src/db/schema.sql
@src/db/types.ts
@src/db/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database schema -- player_messages table with ring buffer trigger</name>
  <files>src/db/schema.sql</files>
  <action>
Append to the end of `src/db/schema.sql` (after the player_spanings section):

1. Add a section header comment: `-- Player messages: ring buffer for behavioral tracking (v1.1)`

2. Create the `player_messages` table:
   - `id` UUID PRIMARY KEY DEFAULT gen_random_uuid()
   - `game_id` UUID NOT NULL REFERENCES games(id) ON DELETE CASCADE
   - `game_player_id` UUID NOT NULL REFERENCES game_players(id) ON DELETE CASCADE
   - `message_text` TEXT NOT NULL
   - `sent_at` TIMESTAMPTZ NOT NULL DEFAULT now()

3. Create a composite index for the primary query pattern (recent messages per player per game):
   `CREATE INDEX IF NOT EXISTS idx_player_messages_player_game ON player_messages (game_id, game_player_id, sent_at DESC);`

4. Create the ring buffer pruning function:
   ```sql
   CREATE OR REPLACE FUNCTION prune_player_messages()
   RETURNS TRIGGER AS $$
   BEGIN
     DELETE FROM player_messages
     WHERE id IN (
       SELECT id FROM player_messages
       WHERE game_id = NEW.game_id
         AND game_player_id = NEW.game_player_id
       ORDER BY sent_at DESC
       OFFSET 10
     );
     RETURN NULL;
   END;
   $$ LANGUAGE plpgsql;
   ```

5. Create the AFTER INSERT trigger:
   ```sql
   CREATE TRIGGER trg_prune_player_messages
     AFTER INSERT ON player_messages
     FOR EACH ROW
     EXECUTE FUNCTION prune_player_messages();
   ```

Follow the exact patterns from the existing schema (IF NOT EXISTS, section comments, consistent naming).
  </action>
  <verify>Read schema.sql and verify: table definition is present, index exists, trigger function and trigger are defined, foreign keys reference games(id) and game_players(id) with ON DELETE CASCADE.</verify>
  <done>player_messages table, index, prune function, and AFTER INSERT trigger are appended to schema.sql.</done>
</task>

<task type="auto">
  <name>Task 2: TypeScript types and CRUD functions for player_messages</name>
  <files>src/db/types.ts, src/db/client.ts</files>
  <action>
**In `src/db/types.ts`:**

1. Add a section header comment before the Database type: `// Player messages types (v1.1)`

2. Add the types (using `type` aliases, NOT `interface` -- per project convention):
   ```typescript
   /** Full player_messages row as returned from the database */
   export type PlayerMessage = {
     id: string;
     game_id: string;
     game_player_id: string;
     message_text: string;
     sent_at: string;
   };

   /** Insert type for player_messages (id and sent_at auto-generated) */
   export type PlayerMessageInsert = Omit<PlayerMessage, "id" | "sent_at">;
   ```

3. Add `player_messages` to the `Database` type definition inside `public.Tables`:
   ```typescript
   player_messages: {
     Row: PlayerMessage;
     Insert: PlayerMessageInsert;
     Update: Partial<PlayerMessageInsert>;
     Relationships: [
       {
         foreignKeyName: "player_messages_game_id_fkey";
         columns: ["game_id"];
         referencedRelation: "games";
         referencedColumns: ["id"];
       },
       {
         foreignKeyName: "player_messages_game_player_id_fkey";
         columns: ["game_player_id"];
         referencedRelation: "game_players";
         referencedColumns: ["id"];
       },
     ];
   };
   ```

**In `src/db/client.ts`:**

1. Add `PlayerMessage` and `PlayerMessageInsert` to the import from `./types.js`.

2. Add a section header comment: `// Player Messages CRUD (v1.1 Data Pipeline)`

3. Add three CRUD functions at the end of the file (before any closing content), following exact codebase patterns (`as` type assertions on `.select('*')` returns, error throw pattern):

   - `createPlayerMessage(msg: PlayerMessageInsert): Promise<void>` -- insert only, no select needed (fire-and-forget). Throws on error.
   - `getRecentPlayerMessages(gameId: string, gamePlayerId: string, limit: number = 10): Promise<PlayerMessage[]>` -- select with .eq game_id, .eq game_player_id, .order sent_at DESC, .limit. Returns `(data ?? []) as PlayerMessage[]`.
   - `getAllRecentMessages(gameId: string): Promise<PlayerMessage[]>` -- select with .eq game_id, .order sent_at DESC. Returns `(data ?? []) as PlayerMessage[]`.

All functions follow the established error handling pattern: `if (error) { throw new Error(\`functionName failed: ${error.message}\`); }`.
  </action>
  <verify>Run `npx tsc --noEmit` to confirm TypeScript compilation passes with zero errors. Verify the three new functions are exported from client.ts.</verify>
  <done>PlayerMessage/PlayerMessageInsert types exported from types.ts, Database definition extended, three CRUD functions exported from client.ts, TypeScript compiles cleanly.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes (TypeScript compiles)
- schema.sql contains player_messages table, index, prune function, and trigger
- types.ts exports PlayerMessage and PlayerMessageInsert
- client.ts exports createPlayerMessage, getRecentPlayerMessages, getAllRecentMessages
- All patterns match existing codebase conventions (type aliases, as assertions, error throws)
- Zero new npm dependencies (CONST-01)
</verification>

<success_criteria>
- player_messages data layer is complete and type-safe
- Ring buffer pruning is handled by PostgreSQL trigger (not application code)
- CRUD functions follow established codebase patterns
- TypeScript compiles without errors
- Ready for Plan 02 to wire up the message capture middleware
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-pipeline/01-01-SUMMARY.md`
</output>
