---
phase: 03-whisper-integration
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/lib/ai-guzman.ts
  - src/handlers/whisper-handler.ts
autonomous: true

must_haves:
  truths:
    - "Whisper generation receives target player's actual message quotes from the database"
    - "Whisper generation receives all-player behavioral overview from GuzmanContext"
    - "Whisper generation receives target player's role for paranoia calibration"
    - "Whisper generation receives round number for escalation"
    - "Generated whispers never contain verbatim player quotes (post-generation safety check)"
    - "Whisper pipeline falls back gracefully if behavioral data is unavailable (CONST-04)"
  artifacts:
    - path: "src/lib/ai-guzman.ts"
      provides: "Updated generateWhisperMessage with expanded signature and verbatim safety check"
      exports: ["generateWhisperMessage"]
    - path: "src/handlers/whisper-handler.ts"
      provides: "Updated sendWhisper gathering behavioral data before whisper generation"
      exports: ["createWhisperHandler", "triggerEventWhisper"]
  key_links:
    - from: "src/handlers/whisper-handler.ts"
      to: "src/lib/behavioral-analysis.ts"
      via: "import selectQuotesForWhisper, buildAllPlayerOverview"
      pattern: "import.*selectQuotesForWhisper.*from"
    - from: "src/handlers/whisper-handler.ts"
      to: "src/db/client.ts"
      via: "import getRecentPlayerMessages"
      pattern: "import.*getRecentPlayerMessages.*from"
    - from: "src/lib/ai-guzman.ts"
      to: "src/lib/ai-prompts.ts"
      via: "buildWhisperPrompt call with 8 params"
      pattern: "buildWhisperPrompt\\("
    - from: "src/handlers/whisper-handler.ts"
      to: "src/lib/ai-guzman.ts"
      via: "generateWhisperMessage call with expanded params"
      pattern: "generateWhisperMessage\\("
---

<objective>
Wire behavioral data through the whisper generation pipeline -- from database fetch to AI generation to safety check.

Purpose: This connects the data preparation helpers (Plan 01) and rewritten prompt (Plan 01) to the actual whisper sending flow. After this plan, every whisper DM Guzman sends will be informed by the target player's actual messages, all players' behavioral patterns, the target's role, and the current round number. A post-generation safety check ensures no verbatim quotes leak through.

Output: Two modified files -- ai-guzman.ts with expanded generateWhisperMessage, whisper-handler.ts with behavioral data gathering in sendWhisper.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-whisper-integration/03-CONTEXT.md
@.planning/phases/03-whisper-integration/03-RESEARCH.md
@.planning/phases/03-whisper-integration/03-01-SUMMARY.md
@src/lib/ai-guzman.ts
@src/handlers/whisper-handler.ts
@src/lib/behavioral-analysis.ts
@src/lib/ai-prompts.ts
@src/db/client.ts
@src/db/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expand generateWhisperMessage signature and add verbatim safety check</name>
  <files>src/lib/ai-guzman.ts</files>
  <action>
Update `generateWhisperMessage` in ai-guzman.ts:

1. **Expand the function signature** to match the new buildWhisperPrompt:
```typescript
export async function generateWhisperMessage(
  gameContext: GuzmanContext,
  targetPlayerName: string,
  targetRole: PlayerRole,
  otherPlayerNames: string[],
  roundEvents: string,
  targetQuotes: string[],
  allPlayerOverview: string,
  roundNumber: number,
): Promise<{ message: string; truthLevel: TruthLevel } | null>
```

2. **Update the buildWhisperPrompt call** inside the function to pass all 8 parameters:
```typescript
content: buildWhisperPrompt(
  gameContext,
  targetPlayerName,
  targetRole,
  otherPlayerNames,
  roundEvents,
  targetQuotes,
  allPlayerOverview,
  roundNumber,
),
```

3. **Update the WhisperResponseSchema** to accept the new "forsakran" (reassurance) truth level:
```typescript
const WhisperResponseSchema = z.object({
  truth_level: z.enum(["truth", "half_truth", "lie", "reassurance"]),
  message: z.string(),
});
```

4. **Add verbatim safety check** after parsing the AI response, before returning. Check if any targetQuote substring (8+ characters, lowercased) appears verbatim in the generated message (lowercased). If detected:
   - Log a warning: `[ai-guzman] Verbatim quote detected in whisper, regenerating once`
   - Retry the AI call ONE time (same params)
   - If the retry also contains verbatim text, log warning and return the retry result anyway (don't block whispers over this -- CONST-04 pattern)
   - Only check quotes that are 8+ characters long (short phrases like "bre" or "wallah" are too common to be meaningful verbatim matches)

5. **Update the TruthLevel mapping**: The parsed `truth_level` from the schema now includes "reassurance". Map it to the existing TruthLevel type. Since TruthLevel in types.ts is `"truth" | "half_truth" | "lie"`, map "reassurance" to "truth" (it's a manipulation tool, closest to truth in intent). Do NOT modify types.ts -- just map at return time:
```typescript
const truthLevel: TruthLevel = parsed.truth_level === "reassurance" ? "truth" : parsed.truth_level;
```

6. **Increase max_tokens from 400 to 500** to accommodate the richer behavioral context in the response.

Keep the existing error handling pattern (try/catch, return null on failure). Keep the existing sanitizeForTelegram call on the message.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Verify the function signature has 8 parameters. Verify the verbatim check logic exists by searching for "Verbatim quote detected" in the file.
  </verify>
  <done>
generateWhisperMessage accepts 8 parameters, passes them to buildWhisperPrompt, handles the "reassurance" truth level, includes a verbatim safety check with one-retry logic, and uses 500 max_tokens. TypeScript compiles clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire behavioral data gathering into sendWhisper in whisper-handler.ts</name>
  <files>src/handlers/whisper-handler.ts</files>
  <action>
Update `sendWhisper` and its surrounding code in whisper-handler.ts:

1. **Add imports** at the top of the file:
```typescript
import { selectQuotesForWhisper, buildAllPlayerOverview } from "../lib/behavioral-analysis.js";
```
This is a NEW import line (behavioral-analysis.js is not currently imported in whisper-handler.ts).

For `getRecentPlayerMessages`: add it to the EXISTING import from `"../db/client.js"`. The file already has an import block like `import { getAllActiveGames, getCurrentRound, ... } from "../db/client.js"` -- merge `getRecentPlayerMessages` into that existing destructured import. Do NOT create a separate import line for it.

2. **Update the `sendWhisper` function** to gather behavioral data before calling generateWhisperMessage:

Inside the try block, after fetching guzmanCtx and before calling generateWhisperMessage:

a. **Fetch target player's recent messages** (non-blocking, with fallback):
```typescript
let targetQuotes: string[] = [];
try {
  const recentMessages = await getRecentPlayerMessages(game.id, target.id, 10);
  targetQuotes = selectQuotesForWhisper(recentMessages, 2);
} catch (err) {
  console.warn("[whisper] Failed to fetch player messages for whisper context:", err instanceof Error ? err.message : err);
  // Continue with empty quotes -- graceful degradation (CONST-04)
}
```

b. **Build all-player overview** from existing playerNotes:
```typescript
const allPlayerOverview = buildAllPlayerOverview(
  guzmanCtx.playerNotes,
  displayName(target.players),
);
```

c. **Get target role** (already available on the target GamePlayer):
```typescript
const targetRole = target.role ?? "akta"; // Fallback to akta if null (shouldn't happen in active game)
```

d. **Get round number**:
```typescript
const roundNumber = round.round_number;
```

3. **Update the generateWhisperMessage call** to pass all 8 parameters:
```typescript
const whisperResult = await generateWhisperMessage(
  guzmanCtx,
  displayName(target.players),
  targetRole,
  otherNames,
  roundEvents,
  targetQuotes,
  allPlayerOverview,
  roundNumber,
);
```

Keep everything else in sendWhisper unchanged -- the queue.send, createWhisper, logging, and error handling all stay the same.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm zero type errors across the entire project. Run `npx tsc --noEmit 2>&1 | head -20` to check for any remaining issues. The full whisper pipeline should compile end-to-end: whisper-handler -> ai-guzman -> ai-prompts with all new parameters.
  </verify>
  <done>
sendWhisper fetches target player's recent messages, selects best quotes via selectQuotesForWhisper, builds all-player overview via buildAllPlayerOverview, extracts target role and round number, and passes all data to generateWhisperMessage. The full whisper pipeline is wired end-to-end. Message fetch failure degrades gracefully (empty quotes). TypeScript compiles with zero errors.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- Full data flow works: whisper-handler.ts fetches messages -> selects quotes -> builds overview -> passes to ai-guzman.ts -> passes to ai-prompts.ts -> prompt includes behavioral data
- Verbatim safety check exists in ai-guzman.ts with one-retry logic
- Graceful degradation: if getRecentPlayerMessages fails, whisper still sends with empty quotes
- No new npm dependencies added (CONST-01)
- Import chain: whisper-handler imports from behavioral-analysis and db/client, ai-guzman imports from ai-prompts
</verification>

<success_criteria>
- The complete whisper pipeline is wired: data gathering -> AI generation -> safety check -> send
- Every whisper Guzman sends is now informed by the target's actual messages, all players' behavioral patterns, target's role, and round number
- Verbatim quotes are caught and regenerated (one retry)
- Behavioral data fetch failure never blocks whisper delivery (CONST-04)
- Zero TypeScript errors across the entire project
- Requirements WHISP-01, WHISP-02, WHISP-03 are fully implemented end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/03-whisper-integration/03-02-SUMMARY.md`
</output>
