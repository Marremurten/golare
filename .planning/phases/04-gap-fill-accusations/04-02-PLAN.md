---
phase: 04-gap-fill-accusations
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/handlers/whisper-handler.ts
autonomous: true

must_haves:
  truths:
    - "Gap-fill commentary adapts to group mood (tense/active/calm) via behavioral data fetched fresh at cron time"
    - "Guzman publicly accuses players with detected anomalies during gap-fill cron slots"
    - "Accusations fire max 2 per round across ALL rounds (locked decision -- no round-based escalation)"
    - "Same player is never accused twice in a row within a game"
    - "If accusation fires, gap-fill is skipped for that slot (no double messages)"
    - "All new AI paths return null on failure -- game never blocks (CONST-04)"
    - "Mood-adaptive gating: tense games always get gap-fill, calm games never, active games only when quiet"
  artifacts:
    - path: "src/handlers/whisper-handler.ts"
      provides: "Accusation delivery, frequency tracking, mood-adaptive gap-fill"
      contains: "accusationTracking"
  key_links:
    - from: "src/handlers/whisper-handler.ts"
      to: "src/lib/behavioral-analysis.ts"
      via: "analyzeBehavior, computeGroupMood, selectAccusationTarget called in runGapFill"
      pattern: "analyzeBehavior|computeGroupMood|selectAccusationTarget"
    - from: "src/handlers/whisper-handler.ts"
      to: "src/lib/ai-guzman.ts"
      via: "generateAccusation called for accusation delivery"
      pattern: "generateAccusation"
    - from: "src/handlers/whisper-handler.ts"
      to: "src/queue/message-queue.ts"
      via: "MessageQueue.send for accusation group messages"
      pattern: "queue\\.send"
---

<objective>
Wire accusation delivery and mood-adaptive gap-fill into the existing gap-fill schedule in whisper-handler.ts.

Purpose: This plan connects the generation functions from Plan 01 to the actual cron-driven delivery pipeline. After this, Guzman will publicly accuse players with detected behavioral anomalies and send mood-aware gap-fill commentary -- all piggybacked on the existing 14:00/20:00 cron schedule.
Output: Extended whisper-handler.ts with accusation tracking, frequency control, mood-adaptive gap-fill gating, and accusation delivery.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-gap-fill-accusations/04-01-SUMMARY.md
@src/handlers/whisper-handler.ts
@src/lib/behavioral-analysis.ts
@src/lib/ai-guzman.ts
@src/db/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Accusation frequency tracking and delivery wiring</name>
  <files>src/handlers/whisper-handler.ts</files>
  <action>
Add in-memory accusation tracking and rewrite `runGapFill()` to support both accusations and mood-adaptive gap-fill. All changes in `whisper-handler.ts`.

**1. Add imports:**

Add to the existing import from `../lib/behavioral-analysis.js`:
- `analyzeBehavior` (already available in ai-guzman.ts but we need fresh data at gap-fill time -- import directly)
- `computeGroupMood` (from Plan 01)
- `selectAccusationTarget` (from Plan 01)

Add to the existing import from `../lib/ai-guzman.js`:
- `generateAccusation` (from Plan 01)

**2. Add accusation tracking state (after the `groupActivity` Map):**

```typescript
// ---------------------------------------------------------------------------
// Accusation frequency tracking
// ---------------------------------------------------------------------------

type AccusationState = {
  roundNumber: number;
  count: number;
  lastTargetName: string | null;
};

/** Per-game accusation tracking. Resets when round changes. */
const accusationTracking = new Map<string, AccusationState>();
```

Add a helper function `canAccuse`:
```typescript
/**
 * Check if an accusation is allowed for this game in the current round.
 * Max 2 accusations per round across ALL rounds (locked user decision).
 * No round-based escalation -- consistent limit.
 * Resets tracking when a new round is detected.
 */
function canAccuse(gameId: string, currentRound: number): boolean {
  const state = accusationTracking.get(gameId);
  if (!state || state.roundNumber !== currentRound) {
    // New round or first check -- reset and allow
    return true;
  }
  return state.count < 2;
}
```

Add a helper function `recordAccusation`:
```typescript
/**
 * Record that an accusation was sent, updating tracking state.
 */
function recordAccusation(gameId: string, roundNumber: number, targetName: string): void {
  const state = accusationTracking.get(gameId);
  if (!state || state.roundNumber !== roundNumber) {
    accusationTracking.set(gameId, { roundNumber, count: 1, lastTargetName: targetName });
  } else {
    state.count++;
    state.lastTargetName = targetName;
  }
}
```

Add a helper function `getLastTargetName`:
```typescript
/**
 * Get the last accused player name for a game (for same-player-twice-in-a-row prevention).
 */
function getLastTargetName(gameId: string): string | null {
  const state = accusationTracking.get(gameId);
  return state?.lastTargetName ?? null;
}
```

Add a mood-adaptive gap-fill gating function:
```typescript
/**
 * Determine if gap-fill should fire based on group mood.
 * - tense: always send (keep pressure up)
 * - active: only when group is quiet (existing behavior)
 * - calm: never send (let calm games breathe)
 *
 * Per user decision: "Mood adaptation affects both content and timing --
 * tense games get more frequent gap-fills, calm games get less"
 */
function shouldSendGapFill(mood: string, isQuiet: boolean): boolean {
  switch (mood) {
    case "tense":
      return true;
    case "calm":
      return false;
    default: // "active" or unknown
      return isQuiet;
  }
}
```

**3. Rewrite `runGapFill()` to support accusations and mood-adaptive gap-fill:**

Replace the existing `runGapFill` function with the following logic. The new flow for each active game is:

```
1. Get current round, players, game context (same as before)
2. Fetch FRESH behavioral data via analyzeBehavior(game.id) -- do NOT rely
   on GuzmanContext.playerNotes which is stale (only updated at result reveal)
   Wrap in try/catch -- if it fails, use existing guzmanCtx.playerNotes as fallback
3. Compute group mood from fresh playerNotes via computeGroupMood()
4. ACCUSATION ATTEMPT (takes priority over gap-fill):
   a. Check canAccuse(game.id, round.round_number)
   b. If allowed: call selectAccusationTarget(freshPlayerNotes, getLastTargetName(game.id))
   c. If target found: call generateAccusation(target.name, target.anomalies, target.evidence, playerNames, guzmanCtx)
   d. If accusation text returned (not null): send via queue.send(game.group_chat_id, ...) and recordAccusation()
   e. If accusation was sent: continue to next game (SKIP gap-fill for this slot)
5. GAP-FILL ATTEMPT (only if no accusation fired):
   a. Check shouldSendGapFill(mood, isGroupQuiet(game.group_chat_id))
   b. If should send: call generateGapFillComment(guzmanCtx, recentActivity, playerNames, mood)
   c. If comment returned: send via queue.send
```

Important details:
- The `analyzeBehavior` call is wrapped in try/catch with a fallback to `guzmanCtx.playerNotes` (CONST-04: non-critical, never blocks game)
- Log `[whisper] Accusation sent to group ${game.group_chat_id} targeting ${target.name}` on accusation delivery
- Log `[whisper] Skipping gap-fill for game ${game.id} -- accusation fired` when skipping gap-fill
- Log `[whisper] Group mood for game ${game.id}: ${mood}` for observability
- Keep all existing error handling patterns (per-game try/catch, outer try/catch)
- `generateGapFillComment` now takes the `mood` string as 4th argument (signature changed in Plan 01)
- `generateAccusation` takes 5 arguments (no roundNumber -- frequency is caller's job)
- Accusations are sent with `{ parse_mode: "HTML" }` (same as gap-fill)

The rewritten `runGapFill` should look approximately like this (full function body, replacing the existing one):

```typescript
async function runGapFill(): Promise<void> {
  try {
    const games = await getAllActiveGames();

    for (const game of games) {
      try {
        const round = await getCurrentRound(game.id);
        if (!round) continue;

        const players = await getGamePlayersOrderedWithInfo(game.id);
        if (players.length === 0) continue;

        const guzmanCtx = await getGuzmanContext(game.id);
        const playerNames = players.map((p) => displayName(p.players));
        const recentActivity = gatherRoundEvents(game, round, players);

        // Fetch FRESH behavioral data (stale GuzmanContext.playerNotes
        // is only updated at result reveal -- Pitfall 2 from research)
        let freshPlayerNotes = guzmanCtx.playerNotes;
        try {
          const { playerNotes } = await analyzeBehavior(game.id);
          freshPlayerNotes = playerNotes;
        } catch (err) {
          console.warn(
            "[whisper] Fresh behavioral analysis failed, using existing playerNotes:",
            err instanceof Error ? err.message : err,
          );
        }

        // Compute group mood
        const mood = computeGroupMood(freshPlayerNotes);
        console.log(`[whisper] Group mood for game ${game.id}: ${mood}`);

        // --- ACCUSATION ATTEMPT (priority over gap-fill) ---
        let accusationFired = false;

        if (canAccuse(game.id, round.round_number)) {
          const target = selectAccusationTarget(
            freshPlayerNotes,
            getLastTargetName(game.id),
          );

          if (target) {
            const accusationText = await generateAccusation(
              target.name,
              target.anomalies,
              target.evidence,
              playerNames,
              guzmanCtx,
            );

            if (accusationText) {
              const queue = getMessageQueue();
              await queue.send(game.group_chat_id, accusationText, {
                parse_mode: "HTML",
              });

              recordAccusation(game.id, round.round_number, target.name);
              accusationFired = true;

              console.log(
                `[whisper] Accusation sent to group ${game.group_chat_id} targeting ${target.name} in game ${game.id}`,
              );
            }
          }
        }

        // --- GAP-FILL ATTEMPT (only if no accusation fired) ---
        if (accusationFired) {
          console.log(
            `[whisper] Skipping gap-fill for game ${game.id} -- accusation fired`,
          );
          continue;
        }

        if (!shouldSendGapFill(mood, isGroupQuiet(game.group_chat_id))) continue;

        const comment = await generateGapFillComment(
          guzmanCtx,
          recentActivity,
          playerNames,
          mood,
        );

        if (!comment) continue;

        const queue = getMessageQueue();
        await queue.send(game.group_chat_id, comment, {
          parse_mode: "HTML",
        });

        console.log(
          `[whisper] Sent gap-fill comment to group ${game.group_chat_id} for game ${game.id}`,
        );
      } catch (gameErr) {
        console.error(
          `[whisper] Gap-fill failed for game ${game.id}:`,
          gameErr,
        );
      }
    }
  } catch (err) {
    console.error("[whisper] runGapFill failed:", err);
  }
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` -- no type errors. Verify:
1. `accusationTracking` Map exists
2. `canAccuse`, `recordAccusation`, `getLastTargetName`, `shouldSendGapFill` helper functions exist
3. `canAccuse` uses a flat `state.count < 2` check with NO round-based branching
4. `runGapFill` calls `analyzeBehavior`, `computeGroupMood`, `selectAccusationTarget`, `generateAccusation`
5. `generateAccusation` is called with 5 arguments (no roundNumber)
6. `generateGapFillComment` is called with 4 arguments (mood added)
7. Accusation delivery uses `queue.send` with `parse_mode: "HTML"`
8. No imports of `PlayerRole` in accusation path
  </verify>
  <done>
runGapFill delivers mood-adaptive gap-fill and piggybacked accusations. Frequency tracking enforces a consistent max 2 accusations per round across ALL rounds (per locked user decision -- no round-based escalation). Same player never accused twice in a row. Accusation fires take priority over gap-fill (no double messages). Fresh behavioral data fetched at cron time with graceful fallback. All AI paths return null on failure (CONST-04).
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `accusationTracking` in-memory Map tracks per-game round counts and last target
3. `canAccuse` enforces consistent max 2 per round across ALL rounds (no round-based branching)
4. `selectAccusationTarget` receives `getLastTargetName()` to prevent same-player-twice-in-a-row
5. `generateAccusation` called only when anomaly target exists and frequency allows
6. `generateAccusation` called with 5 args (no roundNumber)
7. Accusation delivery skips gap-fill for that slot
8. `shouldSendGapFill` gates by mood: tense=always, active=when quiet, calm=never
9. `generateGapFillComment` receives mood string as 4th parameter
10. Fresh `analyzeBehavior()` at cron time with try/catch fallback to existing playerNotes
11. No player role information flows into accusation path
</verification>

<success_criteria>
Accusation system is fully wired: behavioral data flows from analyzeBehavior through mood computation and target selection into AI-generated accusations delivered via MessageQueue. Gap-fill commentary adapts to group mood. Frequency controls prevent spam with a consistent max 2 per round (locked decision). All AI paths degrade gracefully. The group chat will feel like Guzman is always watching.
</success_criteria>

<output>
After completion, create `.planning/phases/04-gap-fill-accusations/04-02-SUMMARY.md`
</output>
