---
phase: 02-game-lobby
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema.sql
  - src/db/types.ts
  - src/db/client.ts
  - src/handlers/lobby.ts
  - src/lib/messages.ts
  - src/lib/errors.ts
  - src/bot.ts
autonomous: true

must_haves:
  truths:
    - "Admin sends /nyttspel in a group and a lobby message appears with join/leave buttons"
    - "Players tap 'Jag √§r med!' and the lobby message updates live with their name"
    - "Players tap 'Hoppa av' and the lobby message updates to remove them"
    - "'K√∂r ig√•ng!' button only appears when admin is viewing and player count >= 4"
    - "Only group admins can create games via /nyttspel"
    - "Only one active game per group is allowed"
    - "Players who haven't /start'd the bot cannot join"
  artifacts:
    - path: "src/db/schema.sql"
      provides: "games and game_players tables with indexes and constraints"
      contains: "CREATE TABLE IF NOT EXISTS games"
    - path: "src/db/types.ts"
      provides: "Game, GamePlayer, GameState, PlayerRole types"
      contains: "GameState"
    - path: "src/db/client.ts"
      provides: "Game CRUD functions (createGame, getActiveGame, addPlayerToGame, removePlayerFromGame, getGamePlayers, updateGame)"
      exports: ["createGame", "getActiveGame", "addPlayerToGame", "removePlayerFromGame", "getGamePlayers"]
    - path: "src/handlers/lobby.ts"
      provides: "Lobby Composer with /nyttspel command and join/leave/start callback handlers"
      exports: ["lobbyHandler"]
    - path: "src/lib/messages.ts"
      provides: "Lobby message templates (LOBBY_CREATED, LOBBY_TEXT, LOBBY_FULL, etc.)"
      contains: "LOBBY_"
  key_links:
    - from: "src/handlers/lobby.ts"
      to: "src/db/client.ts"
      via: "createGame, getActiveGame, addPlayerToGame, removePlayerFromGame, getGamePlayers"
      pattern: "import.*from.*db/client"
    - from: "src/handlers/lobby.ts"
      to: "src/lib/messages.ts"
      via: "MESSAGES.LOBBY_*"
      pattern: "MESSAGES\\.LOBBY"
    - from: "src/handlers/lobby.ts"
      to: "src/queue/message-queue.ts"
      via: "getMessageQueue for lobby message send"
      pattern: "getMessageQueue"
    - from: "src/bot.ts"
      to: "src/handlers/lobby.ts"
      via: "bot.use(lobbyHandler)"
      pattern: "lobbyHandler"
---

<objective>
Create the game lobby system: database schema for games and game_players, all DB helper functions, the /nyttspel command, and join/leave/start inline button handlers that update the lobby message live.

Purpose: This is the foundation for Phase 2. Without the game schema and lobby flow, nothing else (roles, rules, status) can function.
Output: Working lobby where admin creates game, players join/leave via buttons, lobby message updates live, admin can start the game.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-game-lobby/02-RESEARCH.md

@src/db/types.ts
@src/db/client.ts
@src/db/schema.sql
@src/bot.ts
@src/lib/messages.ts
@src/lib/errors.ts
@src/handlers/start.ts
@src/queue/message-queue.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database schema, types, and game CRUD functions</name>
  <files>
    src/db/schema.sql
    src/db/types.ts
    src/db/client.ts
  </files>
  <action>
**schema.sql** -- Append to existing file (keep players table DDL):

Add `games` table:
- id: UUID PK default gen_random_uuid()
- group_chat_id: BIGINT NOT NULL
- admin_user_id: BIGINT NOT NULL
- lobby_message_id: BIGINT (nullable, set after sending lobby message)
- state: TEXT NOT NULL DEFAULT 'lobby' (valid: 'lobby', 'active', 'finished', 'cancelled')
- round: INT NOT NULL DEFAULT 0
- ligan_score: INT NOT NULL DEFAULT 0
- aina_score: INT NOT NULL DEFAULT 0
- team_size: INT (nullable, set at game start from balancing table)
- created_at: TIMESTAMPTZ NOT NULL DEFAULT now()
- updated_at: TIMESTAMPTZ NOT NULL DEFAULT now()

Add partial unique index: `CREATE UNIQUE INDEX idx_one_active_game_per_group ON games (group_chat_id) WHERE state NOT IN ('finished', 'cancelled');`
Add regular index on group_chat_id.
Add updated_at trigger reusing update_updated_at_column() from players.

Add `game_players` table:
- id: UUID PK default gen_random_uuid()
- game_id: UUID NOT NULL REFERENCES games(id) ON DELETE CASCADE
- player_id: UUID NOT NULL REFERENCES players(id) ON DELETE CASCADE
- role: TEXT (nullable, set at game start to 'akta'|'golare'|'hogra_hand')
- joined_at: TIMESTAMPTZ NOT NULL DEFAULT now()
- UNIQUE constraint on (game_id, player_id)

Add indexes on game_id and player_id.

**types.ts** -- Add to existing file (keep Player/Database types):

Add type aliases (NOT interfaces, per project convention):
- `GameState = "lobby" | "active" | "finished" | "cancelled"`
- `PlayerRole = "akta" | "golare" | "hogra_hand"`
- `Game` type matching games table columns
- `GameInsert` type with required: group_chat_id, admin_user_id; optional: lobby_message_id, state
- `GamePlayer` type matching game_players table columns
- `GamePlayerInsert` type with required: game_id, player_id; optional: role

Update the `Database` type to include `games` and `game_players` in its Tables section (same pattern as players: Row, Insert, Update, Relationships).

**client.ts** -- Add to existing file (keep existing player functions):

Add these functions with type assertions on .select('*') returns (per project convention with Supabase v2.95):

1. `createGame(group_chat_id: number, admin_user_id: number): Promise<Game>` -- insert, select, single, return as Game
2. `getActiveGame(group_chat_id: number): Promise<Game | null>` -- select from games where group_chat_id = X AND state NOT IN ('finished', 'cancelled'), maybeSingle
3. `getGameById(game_id: string): Promise<Game | null>` -- select by id, maybeSingle
4. `updateGame(game_id: string, updates: Partial<Game>): Promise<Game>` -- update, select, single
5. `addPlayerToGame(game_id: string, player_id: string): Promise<GamePlayer>` -- upsert with onConflict: "game_id,player_id" to handle double-clicks gracefully
6. `removePlayerFromGame(game_id: string, player_id: string): Promise<void>` -- delete where game_id AND player_id
7. `getGamePlayers(game_id: string): Promise<GamePlayer[]>` -- select from game_players where game_id, return as GamePlayer[]
8. `getGamePlayersWithInfo(game_id: string): Promise<Array<GamePlayer & { players: Player }>>` -- select('*, players(*)') to get player info (telegram_user_id, username, first_name, dm_chat_id) in one query. Use type assertion for the joined result.
  </action>
  <verify>
Run `npx tsc --noEmit` -- zero errors. Verify types.ts exports GameState, PlayerRole, Game, GamePlayer. Verify client.ts exports all 8 new functions.
  </verify>
  <done>
games and game_players DDL appended to schema.sql. All Game/GamePlayer types defined. All 8 DB functions compile and export correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Lobby handler with /nyttspel, join, leave, start callbacks</name>
  <files>
    src/handlers/lobby.ts
    src/lib/messages.ts
    src/lib/errors.ts
    src/bot.ts
  </files>
  <action>
**messages.ts** -- Add lobby message templates to the existing MESSAGES object:

- `LOBBY_CREATED: (adminName: string) => string` -- Guzman announces a new game. Example: "Yo, {adminName} vill starta en st√∂t! üî•\nVem √§r med? Tryck 'Jag √§r med!' bre."
- `LOBBY_TEXT: (players: string[], maxPlayers: number) => string` -- Dynamic lobby status showing count and player names. Format: "{count}/{maxPlayers} spelare: @name1, @name2, @name3\n\nTryck 'Jag √§r med!' f√∂r att hoppa in, bre." (per user decision: names and count update live)
- `LOBBY_FULL: string` -- "Fullt bre! Max 10 spelare. üö´"
- `LOBBY_NOT_REGISTERED: string` -- "Du m√•ste starta boten f√∂rst! Skicka /start till mig privat. üëä" (shown as answerCallbackQuery toast)
- `LOBBY_ALREADY_JOINED: string` -- "Du √§r redan med, bre. Lugn. üòé" (answerCallbackQuery toast)
- `LOBBY_NOT_IN_GAME: string` -- "Du √§r inte med i spelet, bre. ü§∑" (answerCallbackQuery toast)
- `LOBBY_MIN_PLAYERS: (min: number) => string` -- "Det beh√∂vs minst {min} spelare f√∂r att k√∂ra, bre. ‚è≥" (answerCallbackQuery toast)
- `LOBBY_NOT_ADMIN: string` -- "Bara admins kan starta spel h√§r, bre. üö´"
- `LOBBY_GAME_EXISTS: string` -- "Det finns redan ett spel ig√•ng i den h√§r gruppen, bre! üéÆ"
- `LOBBY_NO_GAME: string` -- "Det finns inget aktivt spel h√§r, bre. K√∂r /nyttspel f√∂r att starta ett! üéØ"

**errors.ts** -- Add `LOBBY_ERROR` array with 4-5 Guzman-voice variants for unexpected lobby failures.

**lobby.ts** -- Create new file. Export `lobbyHandler` as a `new Composer()`.

Helper functions within the file:

`isGroupAdmin(ctx, chatId, userId): Promise<boolean>` -- Call ctx.api.getChatMember(chatId, userId), return true if status is "creator" or "administrator". Catch errors and return false.

`buildLobbyKeyboard(gameId: string, playerCount: number, minPlayers: number): InlineKeyboard` -- Always show "Jag √§r med! ü§ù" (callback: `join:{gameId}`) and "Hoppa av üëã" (callback: `leave:{gameId}`). Add row with "K√∂r ig√•ng! üî•" (callback: `start:{gameId}`) only when playerCount >= minPlayers. Note: The "K√∂r ig√•ng" button is visible to everyone but the start handler checks admin status. This is simpler than per-user keyboards (Telegram doesn't support that without separate messages).

`buildLobbyText(players: Array<{username: string | null, first_name: string | null}>, maxPlayers: number): string` -- Use MESSAGES.LOBBY_TEXT. Display names as @username when available, fall back to first_name, then "Ok√§nd".

`isMessageNotModifiedError(err: unknown): boolean` -- Check if error description includes "message is not modified". Used to silently ignore benign edit races.

**MIN_PLAYERS = 4, MAX_PLAYERS = 10** (constants at top of file)

Command handler `/nyttspel`:
1. Filter to group/supergroup only via `lobbyHandler.chatType(["group", "supergroup"]).command("nyttspel", ...)`
2. Guard: ctx.from must exist
3. Check admin: call isGroupAdmin. If not admin, reply with MESSAGES.LOBBY_NOT_ADMIN and return.
4. Check no active game: call getActiveGame(ctx.chat.id). If exists, reply with MESSAGES.LOBBY_GAME_EXISTS and return.
5. Create game: call createGame(ctx.chat.id, ctx.from.id).
6. Build initial lobby text (0 players) and keyboard (join/leave only, no start button yet since 0 < 4).
7. Send lobby message via getMessageQueue().send() with parse_mode: "HTML" and reply_markup. The queue.send() returns the Message object.
8. Store lobby_message_id: call updateGame(game.id, { lobby_message_id: sentMessage.message_id }).
9. Wrap in try/catch, log errors, reply with getRandomError("LOBBY_ERROR") on failure.

Callback handler `join:{gameId}` (regex: `/^join:(.+)$/`):
1. answerCallbackQuery() first (clear spinner).
2. Extract gameId from ctx.match[1].
3. Get game: getGameById(gameId). If not found or state !== "lobby", return.
4. Check player registered: getPlayerByTelegramId(ctx.from.id). If null, answerCallbackQuery with text: MESSAGES.LOBBY_NOT_REGISTERED, show_alert: true. Return.
5. Check not already in game: getGamePlayers(gameId), check if player.id is already in list. If yes, silently return (no error needed for double-click).
6. Check max players: if players.length >= MAX_PLAYERS, answerCallbackQuery with text: MESSAGES.LOBBY_FULL. Return.
7. addPlayerToGame(gameId, player.id).
8. Re-read players with getGamePlayersWithInfo(gameId) to get updated list with names.
9. Build new lobby text and keyboard (include start button if count >= MIN_PLAYERS).
10. ctx.editMessageText(newText, { reply_markup: newKeyboard, parse_mode: "HTML" }). Catch and ignore "message not modified" errors.
11. Wrap in try/catch for DB errors.

Callback handler `leave:{gameId}` (regex: `/^leave:(.+)$/`):
1. answerCallbackQuery() first.
2. Extract gameId, get game, verify state === "lobby".
3. Get player by telegram ID. If not found, return.
4. removePlayerFromGame(gameId, player.id).
5. Re-read players with getGamePlayersWithInfo, rebuild text and keyboard.
6. ctx.editMessageText. Catch "message not modified".

Callback handler `start:{gameId}` (regex: `/^start:(.+)$/`):
1. answerCallbackQuery() first.
2. Extract gameId, get game, verify state === "lobby".
3. Check admin: verify ctx.from.id === game.admin_user_id (stored at creation). If not, answerCallbackQuery with "Bara den som skapade spelet kan starta det, bre." and return. (We use the stored admin ID rather than re-checking Telegram admin, since the game creator should be the one to start.)
4. Get players with getGamePlayersWithInfo(gameId). If count < MIN_PLAYERS, answerCallbackQuery with MESSAGES.LOBBY_MIN_PLAYERS(MIN_PLAYERS). Return.
5. Update game state to "active": updateGame(gameId, { state: "active" }).
6. Edit lobby message to remove buttons: ctx.editMessageText("Spelet har b√∂rjat! üé¨ Kolla era DMs, bre.", { parse_mode: "HTML" }) -- this replaces the lobby message content and removes the inline keyboard.
7. NOTE: The actual role assignment and DM delivery happens in Plan 02. For now, the start handler just transitions state to "active" and edits the lobby message. Plan 02 will add a `startGame(gameId)` function call here after the state transition.
8. Log: console.log(`[lobby] Game ${gameId} started by user ${ctx.from.id}`).

**bot.ts** -- Add import and registration:
- `import { lobbyHandler } from "./handlers/lobby.js";`
- `bot.use(lobbyHandler);` -- Register AFTER startHandler (order: startHandler, lobbyHandler).
  </action>
  <verify>
Run `npx tsc --noEmit` -- zero errors. Verify lobby.ts exports lobbyHandler. Verify bot.ts imports and registers lobbyHandler. Verify all callback data strings are under 64 bytes (join: + UUID = ~41 bytes max). Verify all Swedish text uses proper √•√§√∂ characters.
  </verify>
  <done>
/nyttspel creates a game and sends a lobby message with inline buttons. Join callback adds player and updates lobby message live. Leave callback removes player and updates. Start callback transitions to active state and edits lobby message to "Spelet har b√∂rjat!". Admin check enforced on /nyttspel. One active game per group enforced. Player registration check on join. All wired into bot.ts.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. All new exports accessible: Game, GamePlayer, GameState, PlayerRole, createGame, getActiveGame, addPlayerToGame, removePlayerFromGame, getGamePlayers, getGamePlayersWithInfo, updateGame, getGameById, lobbyHandler
3. All MESSAGES.LOBBY_* templates use proper √•√§√∂ characters
4. Callback data fits within 64-byte limit
5. bot.ts registers lobbyHandler
</verification>

<success_criteria>
- Admin can invoke /nyttspel in a group to create a lobby with inline buttons
- Players joining/leaving updates the lobby message text and player list
- "K√∂r ig√•ng!" button appears only when >= 4 players are in lobby
- Start transitions game state to "active" and edits lobby message to remove buttons
- Non-admins cannot create games
- Duplicate games in same group are rejected
- Unregistered players (no /start) cannot join
</success_criteria>

<output>
After completion, create `.planning/phases/02-game-lobby/02-01-SUMMARY.md`
</output>
