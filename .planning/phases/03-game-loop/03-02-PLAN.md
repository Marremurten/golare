---
phase: 03-game-loop
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/handlers/game-loop.ts
  - src/bot.ts
  - src/handlers/lobby.ts
autonomous: true

must_haves:
  truths:
    - "At 09:00, Guzman posts a mission message to every active game's group chat"
    - "At 12:00, the designated Capo sees a toggleable player list to nominate a team"
    - "Only the Capo can toggle/confirm the nomination; others are rejected"
    - "Capo can include themselves on the nominated team (standard Avalon-style, per locked decision)"
    - "At 15:00, all players vote JA/NEJ via inline buttons in group chat"
    - "Live vote tally shows who has voted (names checked off) but not how they voted"
    - "After all votes or at deadline, all individual votes are revealed at once"
    - "If NEJ majority, Capo rotates to next player in join order and voting restarts"
    - "If 3 consecutive NEJ in same round, mission auto-fails (Kaos-mataren) and Golare get a point"
    - "Reminders sent via DM and group chat 1h before each deadline"
    - "Capo timeout at 15:00 rotates Capo and counts as failed vote; rotated Capo gets until 18:00 to nominate (one compressed cycle)"
  artifacts:
    - path: "src/handlers/game-loop.ts"
      provides: "All game loop callback handlers and scheduled event logic"
      min_lines: 200
    - path: "src/bot.ts"
      provides: "game-loop handler registered, scheduler wired to real handlers"
      contains: "gameLoopHandler"
  key_links:
    - from: "src/handlers/game-loop.ts"
      to: "src/lib/game-state.ts"
      via: "uses FSM for phase transitions"
      pattern: "nextRoundPhase|getCapoIndex|computeVoteResult"
    - from: "src/handlers/game-loop.ts"
      to: "src/db/client.ts"
      via: "reads/writes rounds, votes via CRUD"
      pattern: "createRound|updateRound|castVote|getVotesForRound"
    - from: "src/handlers/game-loop.ts"
      to: "src/lib/messages.ts"
      via: "uses template messages for all game communications"
      pattern: "MESSAGES\\.MISSION_POST|MESSAGES\\.NOMINATION_PROMPT|MESSAGES\\.VOTE_"
    - from: "src/bot.ts"
      to: "src/handlers/game-loop.ts"
      via: "handler registration and scheduler handler wiring"
      pattern: "bot\\.use\\(gameLoopHandler\\)"
---

<objective>
Implement the mission posting, Capo nomination, and team voting phases of the game loop -- covering the first 3 daily events (09:00 mission, 12:00 nomination, 15:00 voting) with all edge cases (failed votes, Capo rotation, Kaos-mataren, reminders, timeouts).

Purpose: This is the core interactive game loop. Players experience the social deduction mechanics through nomination and voting. Without this, there is no game.

Output: game-loop.ts handler with callback handlers for nomination/voting, scheduler handlers wired to real logic in bot.ts, lobby.ts updated to assign join_order at game start.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-game-loop/03-CONTEXT.md
@.planning/phases/03-game-loop/03-RESEARCH.md
@.planning/phases/03-game-loop/03-01-SUMMARY.md
@src/db/types.ts
@src/db/client.ts
@src/lib/game-state.ts
@src/lib/scheduler.ts
@src/lib/messages.ts
@src/handlers/lobby.ts
@src/bot.ts
@src/queue/message-queue.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Game loop handler -- mission posting, nomination, and voting</name>
  <files>
    src/handlers/game-loop.ts
  </files>
  <action>
Create `src/handlers/game-loop.ts` as a new Composer (following the established handler pattern from lobby.ts and game-commands.ts).

**Scheduler handler functions** (exported for bot.ts to wire into scheduler):

1. `handleMissionPost()` -- Called at 09:00:
   - Call `getAllActiveGames()` to get all games with state='active'
   - For each game:
     - Get current round. If no round exists, this is round 1 -- create it.
     - If a round exists and phase is 'reveal' from yesterday, create next round (round_number + 1).
     - If round_number > 5, this shouldn't happen (game should be finished). Log and skip.
     - Determine Capo using `getCapoIndex(playerCount, roundNumber, 0)` (0 failed votes at start of round). Get players with `getGamePlayersOrdered(game_id)`.
     - Set capo_player_id on the round. Update game.round to the new round_number.
     - Send MISSION_POST template to group via MessageQueue.
     - Update round phase to 'mission_posted' (it already is from creation, but explicit).

2. `handleNominationReminder()` -- Called at 11:00:
   - For each active game, get current round.
   - If phase is 'mission_posted' (nomination hasn't happened yet -- it transitions to 'nomination' at 12:00 when the prompt is sent):
     - Get the Capo player info (join to players table for DM chat ID and name).
     - Send NOMINATION_REMINDER to group via MessageQueue.
     - Send NOMINATION_REMINDER_DM to Capo's DM via MessageQueue.

3. `handleNominationDeadline()` -- Called at 12:00:
   - For each active game, get current round.
   - If phase is 'mission_posted':
     - Transition to 'nomination' phase.
     - Get Capo player info. Get all players ordered.
     - Build toggleable inline keyboard: each player as a button with `nt:{gameId}:{playerIndex}` callback data (where playerIndex is their 0-based index in the ordered list). Player names shown as "[ ] PlayerName". **The Capo's own name is included in the player list (per locked decision: Capo CAN include themselves on the team, standard Avalon-style).** Also include a disabled-looking confirm row (only shows when correct team size selected).
     - Send the nomination prompt with keyboard to group via MessageQueue. Store the sent message ID as nomination_message_id on the round (for editing).
   - If phase is 'nomination' and team_player_ids is still empty (Capo didn't nominate before 12:00 deadline AND this is a re-check -- actually, nomination phase starts at 12:00 so this won't happen on the first call. This handler fires at 12:00 to START nomination):
     - The timeout case is handled by the VOTING deadline at 15:00 if still in 'nomination' phase.

4. `handleVotingReminder()` -- Called at 14:00:
   - For each active game, get current round.
   - If phase is 'nomination' and team_player_ids is empty (Capo hasn't nominated yet):
     - This is the "1h before voting" reminder. The Capo still hasn't acted.
     - Re-send reminder to group and DM.
   - If phase is 'voting':
     - Get voters who haven't voted yet. Send reminders to group and DM.

5. `handleVotingDeadline()` -- Called at 15:00:
   - For each active game, get current round.
   - If phase is 'nomination' (Capo never nominated):
     - This is a nomination TIMEOUT. Increment consecutive_failed_votes.
     - Send NOMINATION_TIMEOUT message to group.
     - Check if consecutive_failed_votes >= 3: if so, trigger Kaos-mataren (see below).
     - Otherwise: Rotate Capo to next player. Update round with new capo_player_id and keep phase='nomination'. Send new nomination prompt with keyboard to group.
     - **DEADLINE FOR ROTATED CAPO:** The rotated Capo gets until 18:00 (the next scheduled event -- execution deadline) to submit their nomination. This is a compressed schedule: the 18:00 handler will check if the round is still in 'nomination' phase and treat it as another timeout (increment consecutive_failed_votes, rotate again or trigger Kaos-mataren). The rotated Capo has a 3-hour window (15:00-18:00) instead of the normal 3-hour window (12:00-15:00). This keeps the daily rhythm intact -- at most one rotation per scheduled window.
   - If phase is 'voting':
     - Deadline reached -- resolve the vote.
     - Call `getVotesForRound(round.id)` to get all cast votes.
     - Call `computeVoteResult(votes, totalPlayers)`.
     - Edit the vote message (vote_message_id) to show VOTE_REVEAL with all individual votes exposed.
     - If approved (jaCount > nejCount):
       - Send VOTE_APPROVED to group.
       - Transition to 'execution' phase (will be handled by 18:00 execution deadline).
     - If rejected:
       - Increment consecutive_failed_votes.
       - Send VOTE_REJECTED with Kaos-mataren escalation:
         - If consecutive_failed_votes === 1: also send KAOS_WARNING_1
         - If consecutive_failed_votes === 2: also send KAOS_WARNING_2
         - If consecutive_failed_votes >= 3: send KAOS_TRIGGERED, auto-fail the mission (set mission_result='kaos_fail', ligan_point=false, update aina_score on game), transition to 'reveal' phase. The 21:00 handler will announce the result.
       - If not kaos: Rotate Capo to next player. Update round. Stay in 'nomination' phase for the new Capo to try (compressed -- the nomination keyboard is re-sent immediately). **The new Capo after a rejected vote gets until 18:00 to nominate.** If still in 'nomination' at 18:00, the execution deadline handler treats it as another timeout.

   **Kaos-mataren escalation** (per locked decision -- displayed through Guzman's escalating tone, no visual counter):
   - After 1st failed vote: KAOS_WARNING_1 (nervous Guzman)
   - After 2nd failed vote: KAOS_WARNING_2 (angry Guzman)
   - After 3rd: KAOS_TRIGGERED (maximum aggression, auto-fail)

**Callback handlers** (on the Composer):

6. **Nomination toggle** -- `callbackQuery(/^nt:(.+):(\d+)$/)`:
   - Extract gameId and playerIndex from callback data.
   - Get the game and current round. Verify round is in 'nomination' phase.
   - Verify ctx.from is the Capo (compare ctx.from.id with Capo's telegram_user_id via the players table). If not Capo, answerCallbackQuery with "Bara Capo kan valja team, bre." and return.
   - Get ordered players. Toggle the player at playerIndex in/out of team_player_ids on the round (add if not present, remove if present). **The Capo can toggle themselves on/off just like any other player (per locked decision: Capo CAN include themselves).**
   - Get team_size from game.team_size. Rebuild the nomination keyboard with current selections (selected players show "[x] Name", unselected show "[ ] Name").
   - If selected count equals team_size, add a "Bekrafta team!" button with callback `nc:{gameId}`.
   - Edit the nomination message (using nomination_message_id or ctx.editMessageText).
   - Answer callback query.

7. **Nomination confirm** -- `callbackQuery(/^nc:(.+)$/)`:
   - Extract gameId.
   - Get game and current round. Verify 'nomination' phase and ctx.from is Capo.
   - Verify team_player_ids has exactly team_size members.
   - Transition round to 'voting' phase via `nextRoundPhase('nomination', 'nomination_submitted')`.
   - Get team member names for display.
   - Send TEAM_PROPOSED to group.
   - Build voting keyboard: two buttons "JA" with `vj:{gameId}:{roundNumber}` and "NEJ" with `vn:{gameId}:{roundNumber}`.
   - Send VOTE_PROMPT with voting keyboard to group via MessageQueue. Store sent message ID as vote_message_id on the round.
   - Edit the nomination message to remove buttons (show final team selection as static text).
   - Answer callback query.

8. **Vote JA** -- `callbackQuery(/^vj:(.+):(\d+)$/)`:
   - Extract gameId and roundNumber.
   - Get game, current round. Verify 'voting' phase and round_number matches.
   - Get player by telegram_user_id within this game. If not found, answer "Du ar inte med i det har spelet, bre."
   - Call `castVote(round.id, gamePlayer.id, 'ja')`. Catch unique constraint error (double-vote) gracefully -- answer "Du har redan rostat, bre."
   - Get updated vote list. Build VOTE_TALLY text showing who has voted (names checked off, but NOT what they voted -- per locked decision).
   - Edit the vote message (vote_message_id) with updated tally and the JA/NEJ keyboard still present.
   - If all players have voted: immediately resolve (same logic as deadline in handler 5 above -- reveal all votes, determine approved/rejected, transition phase). Remove the keyboard from the vote message.
   - Answer callback query with "Rostat!" (toast, not alert).

9. **Vote NEJ** -- `callbackQuery(/^vn:(.+):(\d+)$/)`:
   - Same logic as Vote JA but with 'nej'. Reuse the same resolution logic.

**Important implementation notes:**
- All outbound messages go through `getMessageQueue().send()`, never direct bot.api.
- Use `ctx.editMessageText` for callback-triggered edits, `bot.api.editMessageText(chatId, messageId, text)` for scheduler-triggered edits (no ctx available in scheduler context -- pass bot instance to scheduler handlers).
- Catch "message is not modified" errors and ignore them (reuse the isMessageNotModifiedError pattern from lobby.ts).
- Callback data format uses full game UUID with 2-3 char prefix: `nt:{uuid}:{idx}`, `nc:{uuid}`, `vj:{uuid}:{N}`, `vn:{uuid}:{N}`. All well under 64 bytes.
- The bot instance needs to be accessible in scheduler handlers. Export a function from game-loop.ts like `createScheduleHandlers(bot: Bot)` that returns the ScheduleHandlers object with closures over bot.
  </action>
  <verify>
    Run `npx tsc --noEmit` and confirm zero type errors. Grep game-loop.ts for: MessageQueue usage (getMessageQueue), FSM usage (nextRoundPhase, getCapoIndex, computeVoteResult), DB usage (createRound, updateRound, castVote), callback handlers (nt:, nc:, vj:, vn:).
  </verify>
  <done>
    game-loop.ts exports gameLoopHandler Composer and createScheduleHandlers function. Nomination toggle/confirm callbacks handle team selection (including Capo self-selection). Vote callbacks handle JA/NEJ with live tally and revelation. Kaos-mataren escalation fires on consecutive NEJ. All 5 scheduler handlers (mission post, nomination reminder, nomination deadline, voting reminder, voting deadline) are implemented with real game logic. Nomination timeout at 15:00 rotates Capo with 18:00 as compressed deadline.
  </done>
</task>

<task type="auto">
  <name>Task 2: Bot wiring and lobby join_order assignment</name>
  <files>
    src/bot.ts
    src/handlers/lobby.ts
  </files>
  <action>
1. **src/handlers/lobby.ts** -- In the `start:{gameId}` callback handler, after role assignment (step 6) and before editing the lobby message:
   - Get the players sorted by joined_at ASC: `const orderedPlayers = [...players].sort((a, b) => new Date(a.joined_at).getTime() - new Date(b.joined_at).getTime());`
   - Assign join_order 1, 2, 3... to each player: `await Promise.all(orderedPlayers.map((gp, i) => setJoinOrder(gameId, gp.player_id, i + 1)));`
   - Import `setJoinOrder` from db/client.ts.

2. **src/bot.ts** -- Replace the stub scheduler handlers from Plan 01 with the real handlers:
   - Import `gameLoopHandler` and `createScheduleHandlers` from handlers/game-loop.ts.
   - Register `bot.use(gameLoopHandler)` after lobbyHandler and gameCommandsHandler (the callback handlers for nt:, nc:, vj:, vn: must be registered).
   - Replace the stub scheduler handlers with `const scheduleHandlers = createScheduleHandlers(bot);` and pass to `startScheduler(scheduleHandlers)`.
   - Keep the `recoverMissedEvents(scheduleHandlers)` call in onStart.
  </action>
  <verify>
    Run `npx tsc --noEmit` and confirm zero type errors. Verify lobby.ts calls setJoinOrder. Verify bot.ts registers gameLoopHandler and uses createScheduleHandlers.
  </verify>
  <done>
    Players get join_order assigned at game start. Bot registers game loop handler and wires real scheduler handlers. Nomination and voting callbacks are live. The daily cycle of mission -> nomination -> voting is fully functional.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. game-loop.ts has callback handlers for: nt: (nomination toggle), nc: (nomination confirm), vj: (vote JA), vn: (vote NEJ)
3. game-loop.ts has scheduler handlers for: onMissionPost, onNominationReminder, onNominationDeadline, onVotingReminder, onVotingDeadline
4. lobby.ts assigns join_order to players at game start
5. bot.ts registers gameLoopHandler and wires real schedule handlers
6. All messages go through MessageQueue (grep for getMessageQueue)
7. Kaos-mataren escalation sends KAOS_WARNING_1/2 and KAOS_TRIGGERED messages
8. Vote tally shows who voted but not how (live), then reveals all at once (at deadline/completion)
9. Capo can toggle themselves into the team (nomination keyboard includes Capo in player list)
10. Nomination timeout at 15:00 rotates Capo with clear 18:00 compressed deadline
</verification>

<success_criteria>
The first half of the daily game cycle is functional: missions post at 09:00, Capo gets nomination keyboard at 12:00 with toggleable player selection (including self-selection), voting happens at 15:00 with secret ballots and live tally, failed votes rotate Capo, and 3 consecutive NEJ triggers Kaos-mataren auto-fail. Reminders fire 1h before each deadline. Capo timeout at 15:00 rotates to next player who gets until 18:00 to nominate (compressed schedule).
</success_criteria>

<output>
After completion, create `.planning/phases/03-game-loop/03-02-SUMMARY.md`
</output>
