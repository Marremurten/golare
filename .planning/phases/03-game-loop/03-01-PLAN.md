---
phase: 03-game-loop
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema.sql
  - src/db/types.ts
  - src/db/client.ts
  - src/lib/game-state.ts
  - src/lib/scheduler.ts
  - src/lib/messages.ts
  - src/config.ts
  - src/bot.ts
autonomous: true

must_haves:
  truths:
    - "Game rounds are tracked in the database with phase state per round"
    - "Scheduled events fire at 09:00, 11:00, 12:00, 14:00, 15:00, 17:00, 18:00, 21:00 Europe/Stockholm on weekdays"
    - "Bot recovers missed scheduled events after restart"
    - "FSM transitions are pure functions that can be tested in isolation"
    - "join_order is assigned to players at game start for Capo rotation"
  artifacts:
    - path: "src/db/schema.sql"
      provides: "rounds, votes, mission_actions, sista_chansen tables + join_order column"
      contains: "CREATE TABLE IF NOT EXISTS rounds"
    - path: "src/db/types.ts"
      provides: "Round, Vote, MissionActionRow, SistaChansen, RoundPhase types"
      contains: "RoundPhase"
    - path: "src/db/client.ts"
      provides: "CRUD functions for rounds, votes, mission_actions"
      exports: ["createRound", "updateRound", "getCurrentRound", "castVote", "castMissionAction"]
    - path: "src/lib/game-state.ts"
      provides: "Pure FSM functions for phase transitions, Capo rotation, vote/mission computation"
      exports: ["nextRoundPhase", "getCapoIndex", "computeVoteResult", "computeMissionResult", "getTeamSize"]
    - path: "src/lib/scheduler.ts"
      provides: "Croner-based scheduler with 8 cron jobs and restart recovery"
      exports: ["startScheduler", "stopScheduler"]
  key_links:
    - from: "src/lib/scheduler.ts"
      to: "src/db/client.ts"
      via: "scheduler handlers query active games from DB"
      pattern: "getActiveGames|getAllActiveGames"
    - from: "src/lib/game-state.ts"
      to: "src/db/types.ts"
      via: "FSM uses RoundPhase type"
      pattern: "RoundPhase"
    - from: "src/bot.ts"
      to: "src/lib/scheduler.ts"
      via: "bot startup initializes scheduler"
      pattern: "startScheduler"
---

<objective>
Set up the game loop foundation: database schema for rounds/votes/missions, TypeScript types, database CRUD functions, pure FSM logic, Croner-based scheduler, and all ~30 template messages needed for the game loop.

Purpose: Every other game loop plan depends on this infrastructure -- the schema, the state machine, and the scheduler form the backbone of the entire Phase 3 game cycle.

Output: New tables in schema.sql, types in types.ts, CRUD in client.ts, pure FSM in game-state.ts, scheduler in scheduler.ts, ~30 game loop templates in messages.ts, Croner installed, scheduler wired into bot.ts.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-game-loop/03-CONTEXT.md
@.planning/phases/03-game-loop/03-RESEARCH.md
@src/db/schema.sql
@src/db/types.ts
@src/db/client.ts
@src/lib/messages.ts
@src/lib/errors.ts
@src/lib/roles.ts
@src/config.ts
@src/bot.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database schema, types, and CRUD for game loop</name>
  <files>
    src/db/schema.sql
    src/db/types.ts
    src/db/client.ts
  </files>
  <action>
1. Install croner: `npm install croner`

2. **schema.sql** -- Append these new tables after the existing game_players table:

   - `rounds` table: id (UUID PK), game_id (FK games), round_number (INT 1-5, UNIQUE per game), phase (TEXT with CHECK constraint for 'mission_posted','nomination','voting','execution','reveal'), capo_player_id (FK game_players, nullable), team_player_ids (UUID[] default '{}'), consecutive_failed_votes (INT default 0), mission_result (TEXT nullable -- 'success','fail','kaos_fail'), ligan_point (BOOLEAN nullable), nomination_message_id (BIGINT nullable -- for editing the nomination keyboard), vote_message_id (BIGINT nullable -- for editing the vote tally), created_at/updated_at timestamps. Add updated_at trigger.

   - `votes` table: id (UUID PK), round_id (FK rounds ON DELETE CASCADE), game_player_id (FK game_players), vote (TEXT CHECK 'ja'/'nej'), voted_at timestamp. UNIQUE constraint on (round_id, game_player_id) to prevent double-voting.

   - `mission_actions` table: id (UUID PK), round_id (FK rounds ON DELETE CASCADE), game_player_id (FK game_players), action (TEXT CHECK 'sakra'/'gola'), acted_at timestamp. UNIQUE on (round_id, game_player_id).

   - `sista_chansen` table: id (UUID PK), game_id (FK games ON DELETE CASCADE), guessing_side (TEXT -- 'golare'/'akta'), target_player_id (FK game_players), guessed_by_id (FK game_players), correct (BOOLEAN nullable), guessed_at timestamp.

   - ALTER game_players ADD COLUMN join_order INT. (Use ALTER TABLE IF NOT EXISTS pattern or just ALTER TABLE -- the SQL is run manually in Supabase dashboard.)

   - Add indexes: idx_rounds_game_id, idx_votes_round_id, idx_mission_actions_round_id.

3. **types.ts** -- Add these new types (using `type` not `interface`, per project convention):

   ```typescript
   type RoundPhase = "mission_posted" | "nomination" | "voting" | "execution" | "reveal";
   type VoteChoice = "ja" | "nej";
   type MissionAction = "sakra" | "gola";
   type MissionResult = "success" | "fail" | "kaos_fail";
   type GuessingSide = "golare" | "akta";

   type Round = {
     id: string; game_id: string; round_number: number; phase: RoundPhase;
     capo_player_id: string | null; team_player_ids: string[];
     consecutive_failed_votes: number; mission_result: MissionResult | null;
     ligan_point: boolean | null; nomination_message_id: number | null;
     vote_message_id: number | null; created_at: string; updated_at: string;
   };

   type Vote = { id: string; round_id: string; game_player_id: string; vote: VoteChoice; voted_at: string; };
   type MissionActionRow = { id: string; round_id: string; game_player_id: string; action: MissionAction; acted_at: string; };
   type SistaChansen = { id: string; game_id: string; guessing_side: GuessingSide; target_player_id: string; guessed_by_id: string; correct: boolean | null; guessed_at: string; };
   ```

   Update GamePlayer to include `join_order: number | null`.

   Update the Database type to include rounds, votes, mission_actions, sista_chansen tables.

4. **client.ts** -- Add these CRUD functions:

   - `getAllActiveGames(): Promise<Game[]>` -- SELECT * FROM games WHERE state = 'active'. Used by scheduler to process all games.

   - `createRound(game_id: string, round_number: number, capo_player_id: string): Promise<Round>` -- INSERT into rounds with phase='mission_posted'.

   - `getCurrentRound(game_id: string): Promise<Round | null>` -- SELECT from rounds WHERE game_id ORDER BY round_number DESC LIMIT 1.

   - `updateRound(round_id: string, updates: Partial<Round>): Promise<Round>` -- UPDATE rounds.

   - `castVote(round_id: string, game_player_id: string, vote: VoteChoice): Promise<Vote>` -- INSERT (UNIQUE constraint prevents double-vote). Use upsert with onConflict to handle double-clicks gracefully.

   - `getVotesForRound(round_id: string): Promise<Vote[]>` -- SELECT all votes for a round.

   - `castMissionAction(round_id: string, game_player_id: string, action: MissionAction): Promise<MissionActionRow>` -- INSERT with upsert for double-click safety.

   - `getMissionActionsForRound(round_id: string): Promise<MissionActionRow[]>` -- SELECT all actions for a round.

   - `setJoinOrder(game_id: string, player_id: string, join_order: number): Promise<void>` -- UPDATE game_players SET join_order WHERE game_id AND player_id.

   - `getGamePlayersOrdered(game_id: string): Promise<GamePlayer[]>` -- SELECT from game_players WHERE game_id ORDER BY join_order ASC. Used for Capo rotation.

   - `getGamePlayerByTelegramId(game_id: string, telegram_user_id: number): Promise<GamePlayer | null>` -- JOIN game_players with players to find by telegram_user_id within a specific game.

   - `createSistaChansen(game_id: string, guessing_side: GuessingSide, target_player_id: string, guessed_by_id: string): Promise<SistaChansen>` -- INSERT.

   - `getSistaChansen(game_id: string): Promise<SistaChansen | null>` -- SELECT for a game.

   Export all new types from types.ts and all new functions from client.ts.
  </action>
  <verify>
    Run `npx tsc --noEmit` and confirm zero type errors. Verify croner is in package.json dependencies.
  </verify>
  <done>
    All new types exported from types.ts, all new CRUD functions exported from client.ts, schema.sql has 4 new tables + join_order column, croner installed. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Pure FSM, scheduler, template messages, and bot wiring</name>
  <files>
    src/lib/game-state.ts
    src/lib/scheduler.ts
    src/lib/messages.ts
    src/lib/errors.ts
    src/config.ts
    src/bot.ts
  </files>
  <action>
1. **src/lib/game-state.ts** (NEW) -- Pure function FSM with zero side effects:

   - `type PhaseEvent = "schedule_mission" | "schedule_nomination" | "nomination_submitted" | "schedule_voting" | "vote_approved" | "vote_rejected" | "kaos_triggered" | "schedule_execution" | "schedule_reveal" | "reveal_complete" | "nomination_timeout"`

   - `nextRoundPhase(current: RoundPhase, event: PhaseEvent): RoundPhase` -- Per the research:
     - mission_posted + schedule_nomination -> nomination
     - nomination + nomination_submitted -> voting
     - nomination + nomination_timeout -> nomination (stays, Capo rotated externally)
     - voting + vote_approved -> execution
     - voting + vote_rejected -> nomination (rotate Capo)
     - voting + kaos_triggered -> reveal (auto-fail)
     - execution + schedule_reveal -> reveal
     - reveal + reveal_complete -> mission_posted (next round -- caller handles round transition)
     - Default: return current (no valid transition)

   - `getCapoIndex(playerCount: number, roundNumber: number, failedVotesInRound: number): number` -- (roundNumber - 1 + failedVotesInRound) % playerCount

   - `computeVoteResult(votes: Vote[], totalPlayers: number): { approved: boolean; jaCount: number; nejCount: number; abstainCount: number }` -- majority of actual votes (jaCount > nejCount means approved). Import Vote type.

   - `computeMissionResult(actions: MissionActionRow[], teamSize: number): { success: boolean; golaCount: number }` -- golaCount === 0 means success.

   - `getTeamSize(playerCount: number): number` -- lookup from ROLE_BALANCING imported from roles.ts (reuse existing constant).

   - `getSistaChansenSide(liganScore: number, ainaScore: number): GuessingSide | null` -- if liganScore >= 3 return "golare", if ainaScore >= 3 return "akta", else null.

   - `checkWinCondition(liganScore: number, ainaScore: number): "ligan" | "aina" | null` -- first to 3.

   Export all functions and types.

2. **src/lib/scheduler.ts** (NEW) -- Croner-based event scheduler:

   ```typescript
   import { Cron } from "croner";
   const TIMEZONE = "Europe/Stockholm";
   ```

   - `ScheduleHandlers` interface with 8 handler functions: onMissionPost, onNominationReminder, onNominationDeadline, onVotingReminder, onVotingDeadline, onExecutionReminder, onExecutionDeadline, onResultReveal.

   - `startScheduler(handlers: ScheduleHandlers): void` -- Creates 8 Cron jobs on Mon-Fri schedule:
     - 09:00 -> onMissionPost
     - 11:00 -> onNominationReminder
     - 12:00 -> onNominationDeadline
     - 14:00 -> onVotingReminder
     - 15:00 -> onVotingDeadline
     - 17:00 -> onExecutionReminder
     - 18:00 -> onExecutionDeadline
     - 21:00 -> onResultReveal

   - `stopScheduler(): void` -- Stops all jobs and clears the array.

   - `recoverMissedEvents(handlers: ScheduleHandlers): Promise<void>` -- Exported function that checks active games in DB, compares current time (Stockholm) with each game's current round phase, and fires missed handlers. Logic:
     - Get current hour in Europe/Stockholm
     - For each active game, get current round
     - If round phase is behind what should have happened by now, fire the appropriate handler
     - This is called once at startup

3. **src/lib/messages.ts** -- Add all game loop templates after the existing status section. Use proper Swedish with aao characters. All templates in Guzman persona. Add these message keys:

   MISSION_POST: (roundNumber: number) => string -- "Ligan! Runda {N}. Det Ã¤r dags for en ny stot..." (template -- Phase 4 replaces with AI)
   NOMINATION_PROMPT: (capoName: string, teamSize: number) => string -- "{capoName}, du ar Capo! Valj {teamSize} medlemmar..."
   NOMINATION_REMINDER: (capoName: string) => string -- reminder 1h before deadline
   NOMINATION_REMINDER_DM: (capoName: string) => string -- DM reminder to Capo
   NOMINATION_TIMEOUT: (oldCapo: string, newCapo: string) => string -- timeout rotation message
   TEAM_PROPOSED: (capoName: string, teamNames: string[]) => string -- "{capoName} har valt: ..."
   VOTE_PROMPT: (teamNames: string[]) => string -- "Rosta JA eller NEJ pa det har teamet..."
   VOTE_TALLY: (votedNames: string[], total: number) => string -- "Rostat: {N}/{total}\n{names}"
   VOTE_REVEAL: (votes: Array<{name: string; vote: string}>) => string -- reveals all votes
   VOTE_APPROVED: (teamNames: string[]) => string -- team approved
   VOTE_REJECTED: (nejCount: number, newCapo: string, failedVoteNum: number) => string -- team rejected
   KAOS_WARNING_1: string -- escalating tone (1st consecutive NEJ)
   KAOS_WARNING_2: string -- more aggressive (2nd consecutive NEJ)
   KAOS_TRIGGERED: string -- maximum aggression, auto-fail (3rd NEJ)
   EXECUTION_PROMPT: (roundNumber: number) => string -- DM to team members
   EXECUTION_REMINDER: (playerName: string) => string -- reminder DM
   EXECUTION_REMINDER_GROUP: (playerName: string) => string -- group reminder
   EXECUTION_DEFAULT: string -- defaulted to Sakra
   MISSION_SUCCESS: string -- mission succeeded
   MISSION_FAIL: (golaCount: number) => string -- mission failed with sabotage count
   SCORE_UPDATE: (liganScore: number, ainaScore: number, roundNumber: number) => string
   ROUND_END: (roundNumber: number) => string -- round complete, next round tomorrow
   GAME_WON_LIGAN: (liganScore: number, ainaScore: number) => string
   GAME_WON_AINA: (liganScore: number, ainaScore: number) => string
   SISTA_CHANSEN_INTRO: (guessingSide: string) => string -- group announcement
   SISTA_CHANSEN_DM: (targetDescription: string, playerNames: string[]) => string -- DM to guessers
   SISTA_CHANSEN_GUESS_MADE: (guesserName: string, targetName: string) => string -- group announcement
   SISTA_CHANSEN_CORRECT: (winningSide: string) => string
   SISTA_CHANSEN_WRONG: (winningSide: string) => string
   SISTA_CHANSEN_TIMEOUT: (winningSide: string) => string -- no guess made in time
   FINAL_REVEAL: (roles: Array<{name: string; role: string}>) => string -- all roles revealed
   VOTE_REMINDER: (voterName: string) => string -- reminder for pending voters
   VOTE_REMINDER_DM: (voterName: string) => string -- DM reminder

   IMPORTANT: All Swedish text must use proper aao (a-ring, a-umlaut, o-umlaut). Every template in Guzman's voice (Swedish suburb slang). These are template fallbacks -- Phase 4 will layer AI on top.

4. **src/lib/errors.ts** -- Add a GAME_LOOP_ERROR variant with 4-5 Swedish error messages.

5. **src/config.ts** -- No changes needed (TIMEZONE is in scheduler.ts, not config).

6. **src/bot.ts** -- Wire up the scheduler:
   - Import `startScheduler, stopScheduler` from scheduler.ts
   - Import `recoverMissedEvents` from scheduler.ts
   - After handler registration (step 4) and before bot.start, create placeholder schedule handlers that log "[scheduler] {event} triggered" and query active games. The actual game logic handlers will be implemented in Plans 02/03 -- for now, stub them as async functions that: (a) call getAllActiveGames(), (b) log the game IDs found, (c) return. This proves the scheduler fires and DB queries work.
   - Call `startScheduler(handlers)` before bot.start()
   - After bot.start onStart callback, call `recoverMissedEvents(handlers)` to check for missed events
   - Add `stopScheduler()` to the shutdown handler
  </action>
  <verify>
    Run `npx tsc --noEmit` and confirm zero errors. Run `npx tsx src/bot.ts` briefly to confirm bot starts with scheduler initialized (check for "Golare bot startad!" + no scheduler errors). Ctrl+C to stop.
  </verify>
  <done>
    game-state.ts exports all FSM functions. scheduler.ts exports start/stop/recover. messages.ts has ~30 new game loop templates with proper Swedish. Bot starts cleanly with scheduler and stub handlers wired in. TypeScript compiles with no errors.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm ls croner` shows croner installed
3. game-state.ts exports: nextRoundPhase, getCapoIndex, computeVoteResult, computeMissionResult, getTeamSize, getSistaChansenSide, checkWinCondition
4. scheduler.ts exports: startScheduler, stopScheduler, recoverMissedEvents
5. client.ts exports: getAllActiveGames, createRound, getCurrentRound, updateRound, castVote, getVotesForRound, castMissionAction, getMissionActionsForRound, setJoinOrder, getGamePlayersOrdered, getGamePlayerByTelegramId, createSistaChansen, getSistaChansen
6. messages.ts has all ~30 new game loop templates
7. Bot starts and shuts down cleanly with scheduler
</verification>

<success_criteria>
The game loop foundation is complete: database schema supports rounds/votes/missions/sista-chansen, TypeScript types cover all game loop entities, CRUD functions handle all database operations, FSM transitions are pure and testable, scheduler fires at correct times with restart recovery, and all template messages are ready for use by Plans 02-04.
</success_criteria>

<output>
After completion, create `.planning/phases/03-game-loop/03-01-SUMMARY.md`
</output>
