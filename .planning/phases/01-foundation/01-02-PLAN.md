---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/queue/message-queue.ts
  - src/handlers/dm-flow.ts
autonomous: true

must_haves:
  truths:
    - "25 messages sent rapidly to a group chat all arrive without 429 errors"
    - "Messages are spaced at minimum 3-second intervals per chat"
    - "Bot can generate a deep link URL for a specific group chat"
    - "Bot can call out an unregistered player by name in group with deep link"
    - "Bot sends a reminder in group if player hasn't /start'd after timeout"
  artifacts:
    - path: "src/queue/message-queue.ts"
      provides: "Per-chat rate-limited message queue"
      exports: ["MessageQueue", "messageQueue"]
    - path: "src/handlers/dm-flow.ts"
      provides: "Deep link generation, group callout, reminder timeout"
      exports: ["dmFlow", "generateDeepLink", "callOutPlayer", "announceRegistration"]
  key_links:
    - from: "src/queue/message-queue.ts"
      to: "grammy Bot.api"
      via: "Uses bot.api.sendMessage internally"
      pattern: "bot\\.api\\.sendMessage"
    - from: "src/handlers/dm-flow.ts"
      to: "src/queue/message-queue.ts"
      via: "Sends group messages through the queue"
      pattern: "messageQueue\\.send|messageQueue\\.enqueue"
    - from: "src/handlers/dm-flow.ts"
      to: "src/lib/messages.ts"
      via: "Uses MESSAGES templates for callouts and announcements"
      pattern: "MESSAGES\\."
    - from: "src/handlers/dm-flow.ts"
      to: "src/db/client.ts"
      via: "Checks player registration status"
      pattern: "getPlayerByTelegramId"
---

<objective>
Build the per-chat message queue that respects Telegram's 20 msg/min group rate limit, and the DM permission flow module that generates deep links, calls out unregistered players in group chat, and handles the reminder timeout.

Purpose: The message queue is foundational infrastructure -- every outbound group message in the entire game passes through it. The DM flow ensures every player can receive private messages before any game starts.

Output: A working MessageQueue class that spaces group messages at 3+ second intervals, and a dm-flow module with deep link generation, player callout, registration announcement, and timeout reminder.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Per-chat message queue with rate limiting</name>
  <files>src/queue/message-queue.ts</files>
  <action>
    Create an in-memory per-chat message queue class. This is the primary outbound message path for group chats.

    Design:
    - Class `MessageQueue` that wraps bot.api for all outbound messages
    - Maintains a Map<number, QueuedMessage[]> keyed by chat_id
    - Each chat has its own FIFO queue processed independently
    - Minimum interval between messages to same chat: 3000ms (configurable, respects 20 msg/min = 3s spacing)
    - Processing loop per chat: dequeue, send via bot.api.sendMessage, wait interval, repeat

    QueuedMessage type:
    ```typescript
    interface QueuedMessage {
      chatId: number;
      text: string;
      options?: object;  // reply_markup, parse_mode, etc.
      resolve: (result: any) => void;
      reject: (error: any) => void;
      enqueuedAt: number;  // Date.now() for delay tracking
    }
    ```

    Public API:
    - `constructor(bot: Bot, options?: { minIntervalMs?: number })` -- default 3000ms
    - `async send(chatId: number, text: string, options?: object): Promise<Message>` -- enqueues and returns promise that resolves when message is actually sent
    - `getQueueLength(chatId: number): number` -- for monitoring/debugging
    - `getDelay(chatId: number): number` -- estimated wait time in ms for next message in this chat's queue

    Internal mechanics:
    - `send()` pushes to queue and calls `processQueue(chatId)` if not already processing
    - `processQueue(chatId)` sets a processing flag, loops through queue items, sends each with await, then waits minIntervalMs between sends using a setTimeout promise
    - If send fails with non-429 error, reject the queued message's promise but continue processing queue
    - 429 errors should not happen (auto-retry plugin handles those), but if they slip through, wait and retry once
    - When queue empties, clear the processing flag and remove the chat from the processing Set

    Delay notification:
    - Import MESSAGES from ../lib/messages.js
    - When a message has been in queue > 5000ms before being sent, log a warning (don't send the delay message automatically -- let the caller decide)
    - Export a helper `isDelayed(chatId: number): boolean` that returns true if the oldest queued message for that chat has been waiting > 5000ms

    Create and export a singleton factory:
    ```typescript
    let instance: MessageQueue | null = null;
    export function createMessageQueue(bot: Bot, options?: { minIntervalMs?: number }): MessageQueue {
      instance = new MessageQueue(bot, options);
      return instance;
    }
    export function getMessageQueue(): MessageQueue {
      if (!instance) throw new Error("MessageQueue not initialized -- call createMessageQueue first");
      return instance;
    }
    ```

    Export the class too for testing: `export { MessageQueue }`.
  </action>
  <verify>
    - `npx tsc --noEmit` compiles without errors
    - MessageQueue class exports correctly with send, getQueueLength, getDelay, isDelayed methods
    - Factory functions createMessageQueue and getMessageQueue are exported
  </verify>
  <done>
    MessageQueue class processes per-chat FIFO queues with configurable minimum interval (default 3s). Returns promises that resolve when messages are actually sent. Singleton factory pattern for app-wide access. Delay detection for queue monitoring.
  </done>
</task>

<task type="auto">
  <name>Task 2: DM permission flow -- deep links, callouts, and reminders</name>
  <files>src/handlers/dm-flow.ts</files>
  <action>
    Create the DM permission flow module using grammY Composer pattern. This handles the problem that bots cannot DM users who haven't /start'd.

    1. Deep link generation:
       - Export `generateDeepLink(botUsername: string, groupChatId: number): string`
       - Format: `https://t.me/{botUsername}?start=g_{groupChatId}` (per research recommendation)
       - The payload `g_{groupChatId}` will be parsed by the /start handler (Plan 01-03) to detect deep link origin
       - Deep link payload restrictions: A-Z, a-z, 0-9, _, - only. groupChatId is a number so this is safe (negative group IDs: replace the minus sign with "n" prefix, e.g., g_n1234567 for chat_id -1234567)

    2. Player callout in group:
       - Export `async callOutPlayer(groupChatId: number, player: { telegramUserId: number, firstName?: string, username?: string }, botUsername: string): Promise<void>`
       - Uses MESSAGES.DM_CALLOUT template with the player's first_name (preferred) or username, and the deep link
       - Sends via messageQueue.send() (import getMessageQueue from ../queue/message-queue.js)
       - This is called by game lobby code (Phase 2) when it detects unregistered players, but the function is built now

    3. Registration announcement:
       - Export `async announceRegistration(groupChatId: number, playerName: string): Promise<void>`
       - Uses MESSAGES.REGISTRATION_CONFIRMED_GROUP template with the player name
       - Sends via messageQueue.send() to the group
       - Called after a player successfully /start's via deep link (wired in Plan 01-03)

    4. Reminder timeout:
       - Export `scheduleReminder(groupChatId: number, player: { telegramUserId: number, firstName?: string, username?: string }, botUsername: string, delayMs?: number): NodeJS.Timeout`
       - Default delay: 5 minutes (300_000ms), configurable
       - After delay, checks if player has registered (via getPlayerByTelegramId from ../db/client.js)
       - If still unregistered: sends MESSAGES.DM_REMINDER via messageQueue.send() to group
       - If registered (they completed /start in the meantime): does nothing
       - Returns the timeout handle so callers can cancel it if needed
       - Export `cancelReminder(timeoutHandle: NodeJS.Timeout): void` for cleanup

    5. Pending callout tracking:
       - Maintain an in-memory Map<string, NodeJS.Timeout> keyed by `${groupChatId}_${telegramUserId}` to track active reminders
       - When reminder fires or player registers, clean up the entry
       - Export `cancelPlayerReminder(groupChatId: number, telegramUserId: number): void` to cancel a specific player's reminder (called when they complete /start)

    Per user decisions: Swedish throughout, Guzman in character for callouts and reminders, emojis liberally.
  </action>
  <verify>
    - `npx tsc --noEmit` compiles without errors
    - generateDeepLink produces valid URL format with correct payload encoding
    - All exported functions have correct signatures
    - Negative chat IDs are handled in deep link payload (n prefix)
  </verify>
  <done>
    DM flow module exports generateDeepLink, callOutPlayer, announceRegistration, scheduleReminder, cancelReminder, and cancelPlayerReminder. All group messages route through MessageQueue. Deep link payload format handles negative group chat IDs. Reminder checks registration status before sending.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors across all files including new ones
2. MessageQueue can be instantiated with a bot instance and accepts send() calls
3. generateDeepLink("testbot", -1234567) returns "https://t.me/testbot?start=g_n1234567"
4. All dm-flow functions properly import from message-queue and messages modules
</verification>

<success_criteria>
- MessageQueue spaces messages at 3+ second intervals per chat
- MessageQueue returns promises that resolve when message is actually sent (not just enqueued)
- Deep link URLs follow t.me/{bot}?start=g_{chatId} format with negative ID handling
- Player callout sends personalized message with deep link through queue
- Reminder auto-checks registration status before sending (no false reminders)
- All outbound group messages route through MessageQueue (not direct bot.api calls)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
