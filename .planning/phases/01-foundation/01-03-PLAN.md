---
phase: 01-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - src/handlers/start.ts
  - src/bot.ts
autonomous: false

must_haves:
  truths:
    - "User sends /start in private chat and receives a Swedish Guzman welcome with inline Regler button"
    - "User's telegram_user_id and dm_chat_id are stored in Supabase players table"
    - "User who /start's via deep link gets a different welcome referencing the group context"
    - "After deep-link /start, Guzman announces registration in the originating group chat"
    - "User who /start's when already registered gets a recognition message, not a duplicate"
    - "If registration fails, user sees an in-character error asking them to retry"
    - "Bot process restart does not lose any player data"
  artifacts:
    - path: "src/handlers/start.ts"
      provides: "/start command handler with deep link detection, registration, and error handling"
      exports: ["startHandler"]
    - path: "src/bot.ts"
      provides: "Bot wired with all handlers, message queue initialized, ready to run"
      exports: ["bot"]
  key_links:
    - from: "src/handlers/start.ts"
      to: "src/db/client.ts"
      via: "Calls registerPlayer and getPlayerByTelegramId"
      pattern: "registerPlayer|getPlayerByTelegramId"
    - from: "src/handlers/start.ts"
      to: "src/lib/messages.ts"
      via: "Uses MESSAGES.WELCOME_DIRECT, WELCOME_DEEP_LINK, WELCOME_ALREADY_REGISTERED"
      pattern: "MESSAGES\\.WELCOME"
    - from: "src/handlers/start.ts"
      to: "src/handlers/dm-flow.ts"
      via: "Calls announceRegistration and cancelPlayerReminder after deep-link registration"
      pattern: "announceRegistration|cancelPlayerReminder"
    - from: "src/handlers/start.ts"
      to: "src/lib/errors.ts"
      via: "Calls getRandomError on registration failure"
      pattern: "getRandomError"
    - from: "src/bot.ts"
      to: "src/handlers/start.ts"
      via: "bot.use(startHandler)"
      pattern: "bot\\.use.*startHandler"
    - from: "src/bot.ts"
      to: "src/queue/message-queue.ts"
      via: "createMessageQueue(bot) at startup"
      pattern: "createMessageQueue"
---

<objective>
Build the /start command handler with deep link detection, wire all handlers and the message queue into the bot, and verify the complete foundation works end-to-end.

Purpose: This is the integration plan -- connecting registration, deep link flow, message queue, and database into a working bot. After this plan, all Phase 1 success criteria should be achievable.

Output: A fully wired bot that handles /start (direct and deep link), registers players in Supabase, announces in groups, and routes all messages through the rate-limited queue.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: /start command handler with deep link detection</name>
  <files>src/handlers/start.ts</files>
  <action>
    Create the /start command handler using grammY Composer pattern.

    1. Create Composer-based handler:
       ```typescript
       import { Composer } from "grammy";
       export const startHandler = new Composer();
       ```

    2. Handle the /start command (private chat only):
       - Check ctx.chat.type === "private" (ignore /start in groups -- it's a private-only command)
       - Extract deep link payload: `const payload = ctx.match;` (empty string if direct /start)
       - Guard: if ctx.from is undefined, return early (defensive)

    3. Deep link detection:
       - If payload starts with "g_": this is a deep link from a group
       - Parse group chat ID: remove "g_" prefix, replace leading "n" with "-" to restore negative chat ID
       - Example: "g_n1234567" -> groupChatId = -1234567
       - Store parsed groupChatId for use in announcement

    4. Check existing registration:
       - Call getPlayerByTelegramId(ctx.from.id)
       - If player already exists:
         - Reply with MESSAGES.WELCOME_ALREADY_REGISTERED
         - If this was a deep link AND player is already registered, still announce in group (they may have /start'd directly before and are now clicking the deep link)
         - Return early after response

    5. Register new player:
       - Call registerPlayer(ctx.from.id, ctx.chat.id, ctx.from.username, ctx.from.first_name)
       - Wrap in try/catch

    6. On successful registration:
       - If deep link (has groupChatId):
         - Reply with MESSAGES.WELCOME_DEEP_LINK (pass groupChatId or relevant context to template)
         - Call announceRegistration(groupChatId, ctx.from.first_name || ctx.from.username || "Okand") to announce in group
         - Call cancelPlayerReminder(groupChatId, ctx.from.id) to cancel any pending reminder
       - If direct /start (no payload):
         - Reply with MESSAGES.WELCOME_DIRECT
       - Add inline keyboard with one button: `new InlineKeyboard().text("Regler ðŸ“–", "show_rules")` (per user decision: include one inline button alongside welcome text)

    7. On registration failure (catch block):
       - Log the error (console.error with context)
       - Reply with getRandomError("START_FAILED") -- varied in-character error message asking them to retry
       - Do NOT auto-retry (per user decision: ask them to retry directly)

    8. Handle the "show_rules" callback query:
       - Add `startHandler.callbackQuery("show_rules", async (ctx) => { ... })`
       - Answer the callback query first: `await ctx.answerCallbackQuery()`
       - Reply with a placeholder rules message for now: "Reglerna kommer snart, bre! ðŸ”œ" (the /regler command is built in Phase 2)
       - This prevents the "loading" spinner from hanging on the button

    Per user decisions: Swedish throughout, Guzman persona from first message, emojis liberally, context-aware welcome (different for direct vs deep link).
  </action>
  <verify>
    - `npx tsc --noEmit` compiles without errors
    - startHandler exports as a Composer instance
    - Deep link parsing correctly handles "g_n1234567" -> -1234567 and "g_1234567" -> 1234567
  </verify>
  <done>
    /start handler distinguishes direct from deep-link /start, registers player in Supabase, sends appropriate Swedish Guzman welcome with Regler button, announces in group for deep links, handles already-registered gracefully, shows in-character errors on failure.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire handlers and message queue into bot</name>
  <files>src/bot.ts</files>
  <action>
    Update src/bot.ts to wire everything together. Read the existing bot.ts first (from Plan 01-01).

    1. Import and initialize message queue:
       - Import createMessageQueue from ./queue/message-queue.js
       - After bot creation but before handler registration: `const messageQueue = createMessageQueue(bot);`
       - This makes the singleton available via getMessageQueue() throughout the app

    2. Register handlers:
       - Import startHandler from ./handlers/start.js
       - Add: `bot.use(startHandler);`
       - Place handler registration AFTER plugin setup but BEFORE bot.start()

    3. Add bot.me info logging:
       - In the onStart callback, log bot username: `console.log("Bot username: @" + bot.botInfo.username)`
       - This confirms the bot identity and is needed for deep link URL generation

    4. Ensure startup order is:
       a. Config validation (already in config.ts import)
       b. Bot creation
       c. Plugin registration (auto-retry, throttler)
       d. Message queue initialization
       e. Handler registration
       f. Error handler (bot.catch)
       g. Graceful shutdown handlers
       h. bot.start()

    5. Keep the bot export for potential testing use. The file should be both the entry point (runs on import via top-level await) AND export the bot instance.
  </action>
  <verify>
    - `npx tsc --noEmit` compiles without errors
    - Running `npm run dev` with valid .env connects to Telegram and logs bot username
    - Sending /start to the bot in private chat triggers the handler (returns welcome message)
  </verify>
  <done>
    bot.ts initializes message queue, registers startHandler, and starts. Complete startup chain: config -> bot -> plugins -> queue -> handlers -> start. Bot responds to /start in private chat.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify complete foundation end-to-end</name>
  <files>src/bot.ts, src/handlers/start.ts</files>
  <action>
    Human verifies the complete Phase 1 foundation works end-to-end. No code changes in this task -- pure verification of what Tasks 1-2 built.

    What was built: grammY bot with Supabase persistence, rate-limited message queue, /start handler with deep link detection, DM permission flow modules. All messages in Swedish Guzman persona.

    Prerequisites for testing:
    - Copy .env.example to .env, fill in BOT_TOKEN (from @BotFather), SUPABASE_URL, and SUPABASE_SERVICE_ROLE_KEY
    - Run src/db/schema.sql in Supabase SQL Editor to create the players table
  </action>
  <verify>
    1. Start the bot: `npm run dev`
       - Expected: Console shows "Golare bot startad!" and bot username

    2. Send /start to the bot in a PRIVATE chat (direct, no deep link)
       - Expected: Swedish Guzman welcome message with personality and emojis, plus a "Regler" inline button
       - Check Supabase: your telegram_user_id and dm_chat_id should appear in the players table

    3. Send /start again in private chat
       - Expected: Already-registered message (not a duplicate registration)
       - Check Supabase: still only one row for your user

    4. Kill the bot (Ctrl+C) and restart (`npm run dev`)
       - Check Supabase: your player row is still there (persistence survives restart)

    5. (Optional, if you have a test group) Add the bot to a group chat. The deep link flow will be fully testable in Phase 2 when the lobby calls callOutPlayer, but you can manually test generateDeepLink by checking the URL format in the code.

    6. Tap the "Regler" button on the welcome message
       - Expected: A placeholder response (rules come in Phase 2), no hanging spinner
  </verify>
  <done>
    All 6 verification steps pass. Bot connects, registers players in Supabase, survives restarts, responds with Swedish Guzman persona. Type "approved" or describe issues.
  </done>
</task>

</tasks>

<verification>
Phase 1 Success Criteria check:
1. "User sends /start to bot in private chat and receives a welcome response; their user_id and chat_id are stored in Supabase" -- verified by Task 3 step 2
2. "Bot process is killed and restarted; all previously registered players are still present in the database with no data loss" -- verified by Task 3 step 4
3. "Bot sends 25 messages in rapid succession to a group chat; all 25 arrive without hitting Telegram 429 errors" -- MessageQueue with 3s spacing handles this; full test deferred to Phase 2 when group messaging is active (the queue infrastructure is built and wired)
4. "A user who has NOT /start'd the bot taps a deep link in the group; they are guided to private chat, complete /start, and the bot confirms DM access" -- deep link handler built and wired; full flow testable when lobby code calls callOutPlayer (Phase 2)
</verification>

<success_criteria>
- /start in private chat returns Swedish Guzman welcome with inline button
- Player is upserted in Supabase (no duplicates on re-/start)
- Deep link /start (payload "g_*") triggers different welcome + group announcement
- Registration failures show in-character error with retry instruction
- Bot restarts without data loss
- All handlers wired into bot.ts in correct order
- Message queue initialized at startup and available app-wide via getMessageQueue()
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
