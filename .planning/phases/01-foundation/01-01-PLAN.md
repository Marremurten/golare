---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - .env.example
  - .gitignore
  - src/config.ts
  - src/bot.ts
  - src/db/client.ts
  - src/db/schema.sql
  - src/db/types.ts
  - src/lib/messages.ts
  - src/lib/errors.ts
autonomous: true
user_setup:
  - service: telegram
    why: "Bot needs a Telegram Bot Token to connect"
    env_vars:
      - name: BOT_TOKEN
        source: "Talk to @BotFather on Telegram -> /newbot -> copy the token"
  - service: supabase
    why: "Player state persisted in Supabase PostgreSQL"
    env_vars:
      - name: SUPABASE_URL
        source: "Supabase Dashboard -> Settings -> API -> Project URL"
      - name: SUPABASE_SERVICE_ROLE_KEY
        source: "Supabase Dashboard -> Settings -> API -> service_role (secret)"
    dashboard_config:
      - task: "Run the schema.sql in the SQL Editor to create the players table"
        location: "Supabase Dashboard -> SQL Editor -> New query -> paste src/db/schema.sql -> Run"

must_haves:
  truths:
    - "Bot process starts without error and connects to Telegram via long polling"
    - "Supabase client can insert and read from the players table"
    - "Swedish message templates are available for welcome, error, and system messages"
  artifacts:
    - path: "src/bot.ts"
      provides: "grammY Bot instance with auto-retry and throttler plugins, graceful shutdown"
      exports: ["bot"]
    - path: "src/config.ts"
      provides: "Validated environment variables"
      exports: ["config"]
    - path: "src/db/client.ts"
      provides: "Typed Supabase client with service_role key"
      exports: ["supabase"]
    - path: "src/db/schema.sql"
      provides: "PostgreSQL migration for players table"
      contains: "CREATE TABLE players"
    - path: "src/db/types.ts"
      provides: "TypeScript types matching Supabase schema"
      exports: ["Database", "Player"]
    - path: "src/lib/messages.ts"
      provides: "Swedish Guzman-persona message templates"
      exports: ["MESSAGES"]
    - path: "src/lib/errors.ts"
      provides: "Varied error message arrays (3-5 per type)"
      exports: ["ERROR_MESSAGES", "getRandomError"]
  key_links:
    - from: "src/bot.ts"
      to: "src/config.ts"
      via: "imports config.BOT_TOKEN"
      pattern: "config\\.BOT_TOKEN"
    - from: "src/db/client.ts"
      to: "src/config.ts"
      via: "imports config.SUPABASE_URL and config.SUPABASE_SERVICE_ROLE_KEY"
      pattern: "config\\.SUPABASE"
    - from: "src/db/types.ts"
      to: "src/db/schema.sql"
      via: "TypeScript types mirror SQL schema"
      pattern: "telegram_user_id.*number|bigint"
---

<objective>
Set up the project from scratch: initialize Node.js with TypeScript, install grammY and Supabase dependencies, create the bot instance with rate-limit plugins, define the Supabase schema for players, create a typed database client, and write all Swedish message templates in Guzman's persona.

Purpose: Every downstream plan (message queue, /start handler, DM flow) depends on the bot instance, database client, and message templates existing. This plan creates the entire foundation layer.

Output: A running bot skeleton that connects to Telegram, a Supabase schema ready to deploy, a typed DB client, and comprehensive Swedish message templates.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Project initialization and bot skeleton</name>
  <files>
    package.json
    tsconfig.json
    .env.example
    .gitignore
    src/config.ts
    src/bot.ts
  </files>
  <action>
    1. Initialize the project:
       - `npm init -y` then edit package.json: set name "golare", type "module", add scripts: `"dev": "tsx watch src/bot.ts"`, `"start": "tsx src/bot.ts"`
       - Install dependencies: `npm install grammy @supabase/supabase-js @grammyjs/auto-retry @grammyjs/transformer-throttler`
       - Install dev dependencies: `npm install -D typescript @types/node tsx`
       - Create tsconfig.json: target ES2022, module NodeNext, moduleResolution NodeNext, strict true, outDir dist, rootDir src, esModuleInterop true, skipLibCheck true

    2. Create .env.example with placeholder values:
       ```
       BOT_TOKEN=your_telegram_bot_token
       SUPABASE_URL=https://your-project.supabase.co
       SUPABASE_SERVICE_ROLE_KEY=your_service_role_key
       ```

    3. Create .gitignore: node_modules, dist, .env (NOT .env.example)

    4. Create src/config.ts:
       - Read BOT_TOKEN, SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY from process.env
       - Validate all three are present at startup (throw descriptive error if missing, e.g. "Missing BOT_TOKEN -- copy .env.example to .env and fill in values")
       - Export a typed `config` object

    5. Create src/bot.ts:
       - Import Bot from grammy, autoRetry from @grammyjs/auto-retry, apiThrottler from @grammyjs/transformer-throttler
       - Create bot instance: `new Bot(config.BOT_TOKEN)`
       - Register plugins: `bot.api.config.use(apiThrottler())` then `bot.api.config.use(autoRetry({ maxRetryAttempts: 3, maxDelaySeconds: 60 }))`
       - Add bot.catch() error handler that logs errors
       - Add graceful shutdown: process.once("SIGINT") and process.once("SIGTERM") calling bot.stop()
       - At bottom: `await bot.start({ onStart: () => console.log("Golare bot startad!") })`
       - Export bot instance (for use by handlers in later plans)
       - NOTE: Do NOT add any command handlers yet -- those come in Plan 01-03
  </action>
  <verify>
    - `npx tsc --noEmit` compiles without errors
    - `npm run dev` starts without crashing (will fail to connect without .env, but should show "Missing BOT_TOKEN" error, not a crash)
  </verify>
  <done>
    Project has package.json with all dependencies, TypeScript compiles cleanly, bot.ts creates a grammY Bot with auto-retry and throttler plugins and graceful shutdown.
  </done>
</task>

<task type="auto">
  <name>Task 2: Supabase schema and typed database client</name>
  <files>
    src/db/schema.sql
    src/db/types.ts
    src/db/client.ts
  </files>
  <action>
    1. Create src/db/schema.sql with the players table:
       ```sql
       -- Players table: stores Telegram users who have /start'd the bot
       CREATE TABLE IF NOT EXISTS players (
         id               UUID PRIMARY KEY DEFAULT gen_random_uuid(),
         telegram_user_id BIGINT NOT NULL UNIQUE,
         dm_chat_id       BIGINT NOT NULL,
         username         TEXT,
         first_name       TEXT,
         registered_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
         updated_at       TIMESTAMPTZ NOT NULL DEFAULT now()
       );

       CREATE INDEX IF NOT EXISTS idx_players_telegram_user_id ON players (telegram_user_id);

       -- Auto-update updated_at on row change
       CREATE OR REPLACE FUNCTION update_updated_at_column()
       RETURNS TRIGGER AS $$
       BEGIN
         NEW.updated_at = now();
         RETURN NEW;
       END;
       $$ language 'plpgsql';

       CREATE OR REPLACE TRIGGER update_players_updated_at
         BEFORE UPDATE ON players
         FOR EACH ROW
         EXECUTE FUNCTION update_updated_at_column();
       ```
       Use BIGINT for telegram_user_id and dm_chat_id (Telegram IDs can exceed 32-bit int range).

    2. Create src/db/types.ts:
       - Define a `Database` type that mirrors the Supabase schema structure (manual typing, not generated -- keep it simple for v1)
       - Define `Player` interface matching the players table columns exactly
       - Define `PlayerInsert` type (what's needed to insert: telegram_user_id, dm_chat_id required; username, first_name optional)
       - Define `PlayerRow` type (full row as returned from DB)

    3. Create src/db/client.ts:
       - Import createClient from @supabase/supabase-js
       - Import Database type from ./types.js
       - Import config from ../config.js
       - Create and export supabase client: `createClient<Database>(config.SUPABASE_URL, config.SUPABASE_SERVICE_ROLE_KEY, { auth: { persistSession: false, autoRefreshToken: false, detectSessionInUrl: false } })`
       - Add a `registerPlayer` helper function that upserts a player (using onConflict: "telegram_user_id") and returns the player row. Accept telegram_user_id (number), dm_chat_id (number), username (string | undefined), first_name (string | undefined).
       - Add a `getPlayerByTelegramId` helper that queries by telegram_user_id and returns Player | null
       - Export both helpers alongside the supabase client
  </action>
  <verify>
    - `npx tsc --noEmit` compiles without errors
    - Types are consistent: PlayerRow fields match schema.sql columns, registerPlayer return type matches PlayerRow
  </verify>
  <done>
    schema.sql is ready to run in Supabase SQL Editor. TypeScript types match the schema. Database client exports supabase, registerPlayer, and getPlayerByTelegramId with full type safety.
  </done>
</task>

<task type="auto">
  <name>Task 3: Swedish message templates and error variants</name>
  <files>
    src/lib/messages.ts
    src/lib/errors.ts
  </files>
  <action>
    1. Create src/lib/messages.ts with a MESSAGES object containing all Swedish Guzman-persona templates needed for Phase 1:

       WELCOME_DIRECT: Welcome message for direct /start (user found bot themselves). Brief Guzman intro with personality -- Swedish suburb slang (bre, shuno), emojis, attitude. Include something like "Yo bre, valkommen till familjen" + brief explanation of what the bot does + registration confirmation. Keep it 2-4 lines.

       WELCOME_DEEP_LINK: Welcome message for /start via deep link from a group. Reference the game context -- "Shuno, jag ser att du kommer fran gruppen" vibe. Acknowledge they came from the group. Registration confirmation. 2-4 lines.

       WELCOME_ALREADY_REGISTERED: Message when user /start's but is already registered. Guzman recognizes them -- "Bre, du ar redan inne. Lugn." 1-2 lines.

       REGISTRATION_CONFIRMED_GROUP: Group announcement when a player completes /start via deep link. Uses player's first_name or username. Pattern: "{name} ar inne! ðŸ”¥" Something Guzman would say to the group about the new recruit.

       DM_CALLOUT: Group message calling out a specific unregistered player with deep link. Pattern: "Yo {name}, vad vantar du pa? Klicka har bre: {link}" -- direct, personal, social pressure.

       DM_REMINDER: Follow-up group reminder (~5 min later) for player who still hasn't /start'd. More insistent Guzman tone.

       QUEUE_DELAY: Message when queue delay exceeds threshold. "Lugn bre, jag haller pa..." vibe. 1-2 short lines.

       All templates should use template literal functions where they need dynamic data (name, link), and plain strings where static. Export as `MESSAGES`.

    2. Create src/lib/errors.ts with varied error message arrays (3-5 per error type):

       START_FAILED: Array of 4-5 different error messages when /start registration fails. All tell the player to retry: "Bre, det gick inte. Skicka /start igen." variety. Swedish, in character.

       GENERAL_ERROR: Array of 3-4 generic error messages for unexpected failures. In character, tells player something went wrong.

       DB_ERROR: Array of 3-4 messages for when database operations fail. Player-facing (not technical), tells them to retry.

       Export a `getRandomError(type: keyof typeof ERROR_MESSAGES): string` function that picks a random message from the specified array.

       Export `ERROR_MESSAGES` object for direct access if needed.

    Per user decision: Emojis used liberally. Core slang: bre, shuno, aina, para. Everything in Swedish. Guzman is always in character.
  </action>
  <verify>
    - `npx tsc --noEmit` compiles without errors
    - MESSAGES exports all required template keys
    - ERROR_MESSAGES has at least 3 variants per error type
    - getRandomError returns a string
  </verify>
  <done>
    Complete Swedish message template library covering welcome (direct, deep link, already registered), group announcements, DM callouts, reminders, queue delays, and 3-5 varied error messages per error type. All in Guzman's persona with Swedish suburb slang and emojis.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors across all files
2. `npm run dev` starts and either connects to Telegram (if .env exists) or shows clear "Missing BOT_TOKEN" error
3. All exported types/functions are importable: config, bot, supabase, registerPlayer, getPlayerByTelegramId, MESSAGES, ERROR_MESSAGES, getRandomError
4. schema.sql is valid PostgreSQL (no syntax errors if pasted into any SQL runner)
</verification>

<success_criteria>
- Project compiles with TypeScript strict mode
- Bot instance has auto-retry and throttler plugins registered
- Supabase client is configured with service_role key and persistSession: false
- Players table schema has all required columns with correct types (BIGINT for Telegram IDs)
- Message templates cover all Phase 1 interaction points in Swedish with Guzman persona
- Error messages have 3-5 variants per type
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
