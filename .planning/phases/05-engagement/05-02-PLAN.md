---
phase: 05-engagement
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/db/schema.sql
  - src/db/types.ts
  - src/db/client.ts
  - src/handlers/engagement.ts
  - src/lib/game-state.ts
  - src/lib/messages.ts
  - src/lib/ai-prompts.ts
  - src/lib/ai-guzman.ts
  - src/handlers/game-loop.ts
autonomous: true

must_haves:
  truths:
    - "Each Akta player can use Spaning once per game to ask Guzman about a player's role"
    - "Akta Spaning answer is 75% truthful, 25% lie -- creates doubt"
    - "Hogra Hand Spaning is 100% truthful (different presentation from Akta)"
    - "When anyone uses Spaning, Guzman announces it to the group (without revealing who or about whom)"
    - "Rounds 4 and 5 award double points, capped at 3"
    - "Each player's role is revealed one by one at game end -- Akta first, Golare last"
    - "Role reveal happens after Sista Chansen resolves"
  artifacts:
    - path: "src/db/schema.sql"
      provides: "player_spanings table with UNIQUE(game_id, player_id)"
      contains: "CREATE TABLE IF NOT EXISTS player_spanings"
    - path: "src/db/types.ts"
      provides: "PlayerSpaning type alias"
      contains: "PlayerSpaning"
    - path: "src/db/client.ts"
      provides: "CRUD for player_spanings"
      exports: ["createPlayerSpaning", "getPlayerSpaning"]
    - path: "src/handlers/engagement.ts"
      provides: "/spaning command handler with role-based truthfulness"
      contains: "command.*spaning"
    - path: "src/lib/game-state.ts"
      provides: "getRoundPointValue function for anti-blowout scoring"
      exports: ["getRoundPointValue"]
    - path: "src/handlers/game-loop.ts"
      provides: "Modified resolveExecution with double points and one-by-one role reveal"
      contains: "getRoundPointValue"
  key_links:
    - from: "src/handlers/engagement.ts"
      to: "src/db/client.ts"
      via: "createPlayerSpaning for one-per-game enforcement"
      pattern: "createPlayerSpaning"
    - from: "src/handlers/game-loop.ts"
      to: "src/lib/game-state.ts"
      via: "getRoundPointValue call in resolveExecution"
      pattern: "getRoundPointValue"
    - from: "src/handlers/game-loop.ts"
      to: "src/lib/ai-guzman.ts"
      via: "generateIndividualReveal call in performFinalReveal"
      pattern: "generateIndividualReveal"
---

<objective>
Add Spaning (investigation), anti-blowout double-point scoring, and dramatic one-by-one role reveal to complete all Phase 5 engagement mechanics.

Purpose: Spaning gives Akta players a once-per-game investigation tool (unreliable, adding strategic depth). Anti-blowout ensures exciting endgames with comeback potential. The one-by-one role reveal transforms the ending into a dramatic payoff moment.
Output: Extended engagement handler with /spaning, modified game-loop with double scoring and sequential reveal, new AI generation for spaning answers and individual reveals.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-engagement/05-CONTEXT.md
@.planning/phases/05-engagement/05-RESEARCH.md
@.planning/phases/05-engagement/05-01-SUMMARY.md
@src/handlers/engagement.ts
@src/handlers/game-loop.ts
@src/lib/game-state.ts
@src/lib/ai-guzman.ts
@src/lib/ai-prompts.ts
@src/db/schema.sql
@src/db/types.ts
@src/db/client.ts
@src/lib/messages.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Spaning DB, types, CRUD, AI prompts, and /spaning handler</name>
  <files>src/db/schema.sql, src/db/types.ts, src/db/client.ts, src/lib/messages.ts, src/lib/ai-prompts.ts, src/lib/ai-guzman.ts, src/handlers/engagement.ts</files>
  <action>
1. **schema.sql** -- Append the player_spanings table:

```sql
-- Player Spaning: investigation usage tracking (one per player per game)
CREATE TABLE IF NOT EXISTS player_spanings (
  id                UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  game_id           UUID NOT NULL REFERENCES games(id) ON DELETE CASCADE,
  player_id         UUID NOT NULL REFERENCES game_players(id),
  target_player_id  UUID NOT NULL REFERENCES game_players(id),
  answer_truthful   BOOLEAN NOT NULL,
  answer_message    TEXT NOT NULL,
  used_at           TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT unique_spaning_per_player UNIQUE (game_id, player_id)
);

CREATE INDEX IF NOT EXISTS idx_player_spanings_game_id ON player_spanings (game_id);
```

2. **types.ts** -- Add PlayerSpaning type and its insert type:

```typescript
export type PlayerSpaning = {
  id: string;
  game_id: string;
  player_id: string;
  target_player_id: string;
  answer_truthful: boolean;
  answer_message: string;
  used_at: string;
};

export type PlayerSpaningInsert = Omit<PlayerSpaning, "id" | "used_at">;
```

Add the player_spanings table to the Database type definition.

3. **client.ts** -- Add two new CRUD functions:

- `createPlayerSpaning(spaning: PlayerSpaningInsert): Promise<PlayerSpaning>` -- insert and return. Uses standard insert (not upsert). Callers must catch unique violation for "already used" feedback (same pattern as createSistaChansen).
- `getPlayerSpaning(gameId: string, playerId: string): Promise<PlayerSpaning | null>` -- check if player has used their Spaning in this game.

4. **messages.ts** -- Add Spaning-related templates:

```typescript
/** Spaning: prompt to choose who to investigate */
SPANING_TARGET_PROMPT: "Vem vill du unders√∂ka, bre? Du har bara EN chans i hela spelet. V√§lj klokt. üîç",

/** Spaning: already used */
SPANING_ALREADY_USED: "Du har redan anv√§nt din Spaning i det h√§r spelet, bre. En g√•ng √§r en g√•ng. üîí",

/** Spaning: only Akta and Hogra Hand can use it */
SPANING_WRONG_ROLE: "Den h√§r f√∂rm√•gan √§r inte f√∂r dig, bre. üö´",

/** Spaning: group notification (no details about who or target) */
SPANING_GROUP_NOTIFICATION: "N√•gon har bett mig kolla runt... intressant. Mycket intressant. üîç",

/** Spaning: template fallback for Akta (cryptic) */
SPANING_AKTA_TEMPLATE: (targetName: string, isTruthful: boolean, targetRole: string) => {
  const roleName = targetRole === "golare" ? "en r√•tta" : targetRole === "hogra_hand" ? "n√•gon speciell" : "lojal";
  if (isTruthful) {
    return `Jag kollade p√• <b>${targetName}</b> √•t dig, bre...\n\n` +
      `Min k√§nsla s√§ger att den personen √§r... ${roleName}. ` +
      "Men lita inte blint p√• mig -- jag har haft fel f√∂rr. ü§î";
  }
  // Lie: give wrong role hint
  const lieRole = targetRole === "golare" ? "lojal" : "en r√•tta";
  return `Jag kollade p√• <b>${targetName}</b> √•t dig, bre...\n\n` +
    `Min k√§nsla s√§ger att den personen √§r... ${lieRole}. ` +
    "Men lita inte blint p√• mig -- jag har haft fel f√∂rr. ü§î";
},

/** Spaning: template fallback for Hogra Hand (direct, truthful) */
SPANING_HOGRA_HAND_TEMPLATE: (targetName: string, targetRole: string) => {
  const roleName = targetRole === "golare" ? "GOLARE üêÄ" : targetRole === "hogra_hand" ? "Guzmans H√∂gra Hand üîç" : "√ÑKTA ‚úÖ";
  return `Lyssna noga, bre. <b>${targetName}</b> √§r <b>${roleName}</b>. Punkt. üéØ`;
},
```

All Swedish text uses proper characters.

5. **ai-prompts.ts** -- Add Spaning prompt builder:

`buildSpaningPrompt(targetName: string, targetRole: PlayerRole, isTruthful: boolean, investigatorRole: "akta" | "hogra_hand", gameContext: GuzmanContext): string`
- For Akta (cryptic): instruct Guzman to give a vague, hedged answer about the target. If truthful, hint at the correct role obliquely. If lying, hint at a wrong role. Keep it in character -- Guzman's "gut feeling", never certain. Max 500 chars.
- For Hogra Hand (direct): instruct Guzman to state the target's role clearly and definitively. Always truthful. Shorter, more direct. Max 300 chars.

6. **ai-guzman.ts** -- Add Spaning generation function:

`generateSpaningAnswer(targetName: string, targetRole: PlayerRole, isTruthful: boolean, investigatorRole: "akta" | "hogra_hand", gameContext: GuzmanContext): Promise<string>`
- Uses MODEL_MAP.whisper (gpt-4o-mini) for Akta Spaning (needs nuance)
- Uses MODEL_MAP.commentary (gpt-4.1-nano) for Hogra Hand (simple, direct)
- Falls back to MESSAGES.SPANING_AKTA_TEMPLATE or SPANING_HOGRA_HAND_TEMPLATE on failure
- Sanitizes with sanitizeForTelegram

7. **engagement.ts** -- Add /spaning command to the existing Composer:

**`/spaning` command (DM only):**
- Use `.chatType("private").command("spaning", ...)`
- Call getActiveGameContext. If null, reply ENGAGEMENT_NO_GAME
- Check game.state === "active". If not, reply ENGAGEMENT_WRONG_PHASE
- Check player role: must be "akta" or "hogra_hand". If "golare", reply SPANING_WRONG_ROLE
- Check getPlayerSpaning. If already used, reply SPANING_ALREADY_USED
- Build inline keyboard with ALL other players (not just team members). Callback data: `sn:{gameId}:{index}` where index is position in players array. Exclude the investigator themselves
- Reply with SPANING_TARGET_PROMPT and keyboard

**Spaning target callback (`sn:{gameId}:{index}`):**
- Pattern: `/^sn:(.+):(\d+)$/`
- Parse gameId and target index
- Re-verify: game active, player role is akta or hogra_hand, not already used (race condition)
- Resolve target from ordered players
- Determine truthfulness:
  - hogra_hand: always truthful (isTruthful = true)
  - akta: 75% truthful -- `randomInt(0, 100) < 75` (using node:crypto randomInt)
- Generate AI answer: generateSpaningAnswer(targetName, targetRole, isTruthful, playerRole, guzmanContext)
- ATOMIC INSERT: try createPlayerSpaning. Catch unique violation -> reply "already used" and return (same as Sista Chansen pattern)
- Send answer to player's DM
- Send SPANING_GROUP_NOTIFICATION to group chat via MessageQueue (anonymous: "N√•gon har bett mig kolla runt...")
- Answer callback query

**IMPORTANT:** Add /spaning handlers BEFORE the freeform text handler in the Composer (same ordering principle -- commands and callbacks before the catch-all text handler).
  </action>
  <verify>Run `npx tsc --noEmit` from the project root. All new types, CRUD, AI functions, and handler additions should compile. No compilation errors.</verify>
  <done>player_spanings table exists with UNIQUE(game_id, player_id). /spaning works for both Akta (75% truth, cryptic) and Hogra Hand (100% truth, direct). Group gets notified anonymously. AI generation has template fallbacks. TypeScript compiles without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Anti-blowout double scoring and one-by-one dramatic role reveal</name>
  <files>src/lib/game-state.ts, src/lib/messages.ts, src/lib/ai-prompts.ts, src/lib/ai-guzman.ts, src/handlers/game-loop.ts</files>
  <action>
1. **game-state.ts** -- Add getRoundPointValue function:

```typescript
/**
 * Calculate points awarded for a round, considering anti-blowout.
 * Rounds 4 and 5 are worth double points (2 instead of 1).
 * Score is always capped at 3 by the caller (first-to-3 rule).
 */
export function getRoundPointValue(roundNumber: number): number {
  return roundNumber >= 4 ? 2 : 1;
}
```

2. **messages.ts** -- Add role reveal templates:

```typescript
/** Role reveal: intro message before individual reveals */
ROLE_REVEAL_INTRO: "<b>ROLLERNA AVSL√ñJAS</b> üé≠\n\nEn i taget, bre... üëÄ",

/** Role reveal: template fallback for individual reveal */
ROLE_REVEAL_INDIVIDUAL: (playerName: string, role: string) => {
  const emoji = role === "golare" ? "üêÄ" : role === "hogra_hand" ? "üîç" : "üë§";
  const roleName = role === "golare" ? "GOLARE" : role === "hogra_hand" ? "Guzmans H√∂gra Hand" : "√Ñkta";
  return `${emoji} <b>${playerName}</b> -- ${roleName}`;
},

/** Role reveal: finale message after all reveals */
ROLE_REVEAL_FINALE: "Spelet √§r slut. Nu vet ni allt, bre. GG, familjen. ü§ù",

/** Score update with double point info (rounds 4-5) */
SCORE_UPDATE_DOUBLE: (liganScore: number, ainaScore: number, roundNumber: number, pointValue: number) =>
  `<b>St√§llning efter runda ${roundNumber}:</b>\n\n` +
  `  Ligan: ${liganScore} üí∞\n` +
  `  Aina: ${ainaScore} üîµ\n\n` +
  `${pointValue > 1 ? `<i>Dubbelpo√§ng! Runda ${roundNumber} var v√§rd ${pointValue} po√§ng.</i>\n\n` : ""}` +
  `F√∂rst till 3 vinner. ${5 - roundNumber > 0 ? `${5 - roundNumber} rundor kvar.` : "Sista rundan spelad."}`,
```

3. **ai-prompts.ts** -- Add individual role reveal prompt builder:

`buildIndividualRevealPrompt(playerName: string, role: PlayerRole, isLast: boolean, gameContext: GuzmanContext): string`
- Instruct Guzman to dramatically reveal one player's role
- If role is "akta": tone is relieved/warm -- "familjen". Brief.
- If role is "hogra_hand": tone is respectful/mysterious -- Guzman's trusted right hand
- If role is "golare": tone is DRAMATIC BETRAYAL -- the big reveal, maximum suspense
- isLast flag: if true, this is the last Golare reveal -- make it the most dramatic
- Max 300 chars. Use `<b>` and `<i>`

4. **ai-guzman.ts** -- Add individual reveal generation:

`generateIndividualReveal(playerName: string, role: PlayerRole, isLast: boolean, gameContext: GuzmanContext): Promise<string>`
- Uses MODEL_MAP.commentary (gpt-4.1-nano) for cost efficiency -- these are short messages
- Falls back to MESSAGES.ROLE_REVEAL_INDIVIDUAL(playerName, role) on failure
- Sanitizes with sanitizeForTelegram
- Max 300 tokens, temperature 0.9

5. **game-loop.ts** -- Modify resolveExecution for double points:

In the `resolveExecution` function, change the score calculation to use `getRoundPointValue`:

```typescript
import { getRoundPointValue } from "../lib/game-state.js";

// Replace the existing score update lines:
// OLD: const newLiganScore = success ? game.ligan_score + 1 : game.ligan_score;
// OLD: const newAinaScore = success ? game.aina_score : game.aina_score + 1;

// NEW:
const pointValue = getRoundPointValue(round.round_number);
const newLiganScore = success
  ? Math.min(game.ligan_score + pointValue, 3)  // Cap at 3
  : game.ligan_score;
const newAinaScore = success
  ? game.aina_score
  : Math.min(game.aina_score + pointValue, 3);  // Cap at 3
```

Also update the SCORE_UPDATE call to use SCORE_UPDATE_DOUBLE when pointValue > 1:
```typescript
const scoreMsg = pointValue > 1
  ? MESSAGES.SCORE_UPDATE_DOUBLE(newLiganScore, newAinaScore, round.round_number, pointValue)
  : MESSAGES.SCORE_UPDATE(newLiganScore, newAinaScore, round.round_number);
```

**Also apply double points to handleKaosFail:**
```typescript
const pointValue = getRoundPointValue(round.round_number);
const newAinaScore = Math.min(game.aina_score + pointValue, 3);
```

6. **game-loop.ts** -- Modify performFinalReveal for one-by-one reveals:

Replace the existing batch FINAL_REVEAL with sequential per-player reveals:

```typescript
// 4. One-by-one role reveal (replaces batch FINAL_REVEAL)
const players = await getGamePlayersOrderedWithInfo(game.id);

// Sort: akta first, hogra_hand middle, golare last (per user decision)
const sortOrder: Record<string, number> = {
  akta: 0,
  hogra_hand: 1,
  golare: 2,
};
const sortedPlayers = [...players].sort(
  (a, b) => (sortOrder[a.role ?? "akta"] ?? 0) - (sortOrder[b.role ?? "akta"] ?? 0)
);

// Intro message
await queue.send(groupChatId, MESSAGES.ROLE_REVEAL_INTRO, { parse_mode: "HTML" });
await sleep(suspenseDelay);

// Load Guzman context for AI reveals
let guzmanCtx: GuzmanContext | null = null;
try {
  guzmanCtx = await getGuzmanContext(game.id);
} catch { /* non-critical */ }

// Reveal each player one by one
for (let i = 0; i < sortedPlayers.length; i++) {
  const player = sortedPlayers[i];
  const role = player.role ?? "akta";
  const playerName = displayName(player.players);
  const isLast = i === sortedPlayers.length - 1;

  let revealMsg: string;
  try {
    revealMsg = await generateIndividualReveal(playerName, role as PlayerRole, isLast, guzmanCtx!);
  } catch {
    revealMsg = MESSAGES.ROLE_REVEAL_INDIVIDUAL(playerName, role);
  }

  await queue.send(groupChatId, revealMsg, { parse_mode: "HTML" });
  await sleep(suspenseDelay);
}

// Finale message
await queue.send(groupChatId, MESSAGES.ROLE_REVEAL_FINALE, { parse_mode: "HTML" });
```

Import `generateIndividualReveal` from `../lib/ai-guzman.js` and `PlayerRole` from `../db/types.js` at the top of game-loop.ts.

**IMPORTANT:** Do NOT remove the FINAL_REVEAL template from messages.ts -- it may still be referenced elsewhere. Just stop using it in performFinalReveal.
  </action>
  <verify>
1. Run `npx tsc --noEmit` from the project root -- no compilation errors
2. Verify getRoundPointValue(3) returns 1 and getRoundPointValue(4) returns 2
3. Verify performFinalReveal no longer uses MESSAGES.FINAL_REVEAL (grep for it in game-loop.ts)
4. Verify resolveExecution uses getRoundPointValue and Math.min cap
5. Verify handleKaosFail also uses getRoundPointValue and Math.min cap
  </verify>
  <done>
- /spaning works for Akta (75% truth, cryptic) and Hogra Hand (100% truth, direct) with group notification
- Rounds 4-5 award double points (capped at 3) in both resolveExecution and handleKaosFail
- performFinalReveal does one-by-one reveals: Akta first, Hogra Hand middle, Golare last, with AI-generated dramatic text and suspense delays
- All AI generation has template fallbacks
- TypeScript compiles without errors
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes -- all modified files compile
2. schema.sql has player_spanings table with UNIQUE(game_id, player_id)
3. /spaning handler differentiates between Akta (cryptic, 75% truth) and Hogra Hand (direct, 100% truth)
4. getRoundPointValue returns 2 for rounds 4-5, 1 for rounds 1-3
5. resolveExecution and handleKaosFail both use getRoundPointValue with Math.min(score, 3) cap
6. performFinalReveal iterates players sorted by role (akta -> hogra_hand -> golare) with per-player AI reveals
7. Spaning group notification is anonymous ("N√•gon har bett mig kolla runt...")
8. No deferred features implemented (none to defer)
</verification>

<success_criteria>
- Akta player can /spaning once per game, gets a cryptic answer (75% truthful)
- Hogra Hand can /spaning once per game, gets a direct truthful answer
- Group is notified anonymously when anyone uses Spaning
- Rounds 4 and 5 award double points, scores capped at 3
- Game ending shows roles one by one: Akta first, Golare last, with dramatic AI-generated text
- Role reveal happens AFTER Sista Chansen resolves (existing sequencing preserved)
- All AI generation has template fallbacks
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-engagement/05-02-SUMMARY.md`
</output>
