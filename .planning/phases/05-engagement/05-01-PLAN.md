---
phase: 05-engagement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema.sql
  - src/db/types.ts
  - src/db/client.ts
  - src/lib/messages.ts
  - src/lib/ai-prompts.ts
  - src/lib/ai-guzman.ts
  - src/handlers/engagement.ts
  - src/bot.ts
autonomous: true

must_haves:
  truths:
    - "Non-team player can send an anonymous whisper to the group via /viska in DM"
    - "Non-team player can target a whisper at a specific player"
    - "Guzman relays the whisper to the group with a cryptic hint about the sender's role"
    - "Non-team player can surveil a team member via /spana in DM"
    - "Surveiller receives a cryptic clue about the target in their DM"
    - "Surveilled player is sometimes notified (40% chance)"
    - "Whispers and surveillance persist in the database"
  artifacts:
    - path: "src/handlers/engagement.ts"
      provides: "Engagement Composer with /viska, /spana commands, callback handlers, freeform text capture"
      min_lines: 200
    - path: "src/db/schema.sql"
      provides: "anonymous_whispers and surveillance tables"
      contains: "CREATE TABLE IF NOT EXISTS anonymous_whispers"
    - path: "src/db/types.ts"
      provides: "AnonymousWhisper, Surveillance type aliases"
      contains: "AnonymousWhisper"
    - path: "src/db/client.ts"
      provides: "CRUD for anonymous_whispers and surveillance tables"
      exports: ["createAnonymousWhisper", "createSurveillance", "getSurveillanceForPlayerInRound"]
    - path: "src/lib/ai-guzman.ts"
      provides: "AI generation for whisper relay and surveillance clues"
      exports: ["generateWhisperRelay", "generateSurveillanceClue"]
    - path: "src/lib/ai-prompts.ts"
      provides: "Prompt builders for whisper relay and surveillance clues"
      exports: ["buildWhisperRelayPrompt", "buildSurveillanceCluePrompt"]
    - path: "src/lib/messages.ts"
      provides: "Template messages for whisper and surveillance features"
      contains: "WHISPER_RELAY_TEMPLATE"
  key_links:
    - from: "src/handlers/engagement.ts"
      to: "src/lib/ai-guzman.ts"
      via: "generateWhisperRelay and generateSurveillanceClue calls"
      pattern: "generateWhisperRelay|generateSurveillanceClue"
    - from: "src/handlers/engagement.ts"
      to: "src/db/client.ts"
      via: "CRUD calls for anonymous_whispers and surveillance"
      pattern: "createAnonymousWhisper|createSurveillance"
    - from: "src/bot.ts"
      to: "src/handlers/engagement.ts"
      via: "bot.use(engagementHandler) registered AFTER existing handlers"
      pattern: "bot\\.use\\(engagementHandler\\)"
---

<objective>
Add anonymous whisper (/viska) and surveillance (/spana) mechanics so non-team players have meaningful actions during every game round.

Purpose: These two features are the core engagement mechanics that make the async format viable -- without them, non-team players have nothing to do between events.
Output: New engagement handler (Composer), DB tables, AI generation functions, and template fallbacks for anonymous whispers and surveillance.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-engagement/05-CONTEXT.md
@.planning/phases/05-engagement/05-RESEARCH.md
@src/db/schema.sql
@src/db/types.ts
@src/db/client.ts
@src/lib/messages.ts
@src/lib/ai-guzman.ts
@src/lib/ai-prompts.ts
@src/handlers/whisper-handler.ts
@src/bot.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: DB schema, types, CRUD, and template messages for whispers and surveillance</name>
  <files>src/db/schema.sql, src/db/types.ts, src/db/client.ts, src/lib/messages.ts</files>
  <action>
1. **schema.sql** -- Append two new tables at the end of the file:

```sql
-- Anonymous whispers from players relayed through Guzman
CREATE TABLE IF NOT EXISTS anonymous_whispers (
  id                UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  game_id           UUID NOT NULL REFERENCES games(id) ON DELETE CASCADE,
  round_number      INT NOT NULL,
  sender_player_id  UUID NOT NULL REFERENCES game_players(id),
  target_type       TEXT NOT NULL CHECK (target_type IN ('group', 'player')),
  target_player_id  UUID REFERENCES game_players(id),
  original_message  TEXT NOT NULL,
  relayed_message   TEXT NOT NULL,
  sent_at           TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_anon_whispers_game_id ON anonymous_whispers (game_id);

-- Surveillance actions by non-team players
CREATE TABLE IF NOT EXISTS surveillance (
  id                   UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  game_id              UUID NOT NULL REFERENCES games(id) ON DELETE CASCADE,
  round_number         INT NOT NULL,
  surveiller_player_id UUID NOT NULL REFERENCES game_players(id),
  target_player_id     UUID NOT NULL REFERENCES game_players(id),
  clue_message         TEXT NOT NULL,
  target_notified      BOOLEAN NOT NULL DEFAULT FALSE,
  created_at           TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT unique_surveillance_per_round UNIQUE (game_id, surveiller_player_id, round_number)
);

CREATE INDEX IF NOT EXISTS idx_surveillance_game_id ON surveillance (game_id);
```

Note: Surveillance has a UNIQUE constraint on (game_id, surveiller_player_id, round_number) for once-per-round-per-player enforcement (per research discretion decision).

2. **types.ts** -- Add new type aliases in a new "Engagement types (Phase 5)" section:

```typescript
// Engagement types (Phase 5)

export type WhisperTargetType = "group" | "player";

export type AnonymousWhisper = {
  id: string;
  game_id: string;
  round_number: number;
  sender_player_id: string;
  target_type: WhisperTargetType;
  target_player_id: string | null;
  original_message: string;
  relayed_message: string;
  sent_at: string;
};

export type AnonymousWhisperInsert = Omit<AnonymousWhisper, "id" | "sent_at">;

export type Surveillance = {
  id: string;
  game_id: string;
  round_number: number;
  surveiller_player_id: string;
  target_player_id: string;
  clue_message: string;
  target_notified: boolean;
  created_at: string;
};

export type SurveillanceInsert = Omit<Surveillance, "id" | "created_at">;
```

Also add the new tables to the Database type (anonymous_whispers and surveillance tables in the Tables section).

3. **client.ts** -- Add new CRUD functions in a "Engagement CRUD (Phase 5)" section:

- `createAnonymousWhisper(whisper: AnonymousWhisperInsert): Promise<AnonymousWhisper>` -- insert and return the row
- `createSurveillance(surveillance: SurveillanceInsert): Promise<Surveillance>` -- insert with upsert on the UNIQUE constraint, return row. Callers catch unique violation for "already used this round" feedback.
- `getSurveillanceForPlayerInRound(gameId: string, surveillerPlayerId: string, roundNumber: number): Promise<Surveillance | null>` -- check if player already used surveillance this round

Follow existing patterns: type assertions on `.select('*')` returns, throw on error.

4. **messages.ts** -- Add new message templates in an "Engagement messages (Phase 5)" section:

```typescript
// Engagement messages (Phase 5)

/** Prompt user to choose whisper target */
WHISPER_TARGET_PROMPT: "Vem vill du viska till, bre? V√§lj nedan. üëá",

/** Prompt user to type their whisper message */
WHISPER_MESSAGE_PROMPT: "Skriv ditt meddelande. Guzman fixar resten. ü§´",

/** Confirmation after whisper is sent */
WHISPER_SENT_CONFIRM: "Meddelandet har levererats. Ingen vet att det var du, bre. ü§´",

/** Whisper expired (TTL) */
WHISPER_EXPIRED: "Tiden gick ut, bre. K√∂r /viska igen om du vill. ‚è∞",

/** Template fallback for whisper relay when AI is unavailable */
WHISPER_RELAY_TEMPLATE: (whisperText: string) =>
  "<b>Guzman har f√•tt ett anonymt meddelande...</b> üì©\n\n" +
  `<i>"${whisperText}"</i>\n\n` +
  "N√•n i familjen har n√•t att s√§ga. Fr√•gan √§r -- vem? ü§î",

/** Template fallback for targeted whisper relay */
WHISPER_RELAY_TARGETED_TEMPLATE: (targetName: string, whisperText: string) =>
  `<b>Guzman till ${targetName}:</b> üì©\n\n` +
  `N√•n bad mig skicka det h√§r till dig:\n<i>"${whisperText}"</i>\n\n` +
  "Vem det var? Det stannar hos mig, bre. ü§´",

/** Player is on the team -- can't use engagement actions */
ENGAGEMENT_ON_TEAM: "Du √§r med i teamet den h√§r rundan, bre. Fokusera p√• st√∂ten ist√§llet. üéØ",

/** No active game for engagement actions */
ENGAGEMENT_NO_GAME: "Du √§r inte med i n√•got aktivt spel just nu, bre. ü§∑",

/** Game not in a valid phase for engagement actions */
ENGAGEMENT_WRONG_PHASE: "Det finns inget aktivt uppdrag just nu, bre. V√§nta tills n√§sta runda. ‚è≥",

/** Surveillance: prompt to choose target */
SURVEILLANCE_TARGET_PROMPT: "Vem vill du spana p√•, bre? V√§lj en teammedlem. üëá",

/** Surveillance: already used this round */
SURVEILLANCE_ALREADY_USED: "Du har redan spanat den h√§r rundan, bre. V√§nta till n√§sta. üîí",

/** Surveillance: target was notified */
SURVEILLANCE_TARGET_NOTIFIED: "N√•gon har riktat blicken mot dig... üëÄ",

/** Surveillance: confirmation sent to surveiller */
SURVEILLANCE_SENT_CONFIRM: "Guzman har kollat runt √•t dig. Kolla nedan. üîç",

/** Template fallback for surveillance clue when AI is unavailable */
SURVEILLANCE_CLUE_TEMPLATE: (targetName: string) =>
  `Jag kollade p√• <b>${targetName}</b> √•t dig, bre...\n\n` +
  "Sv√•rt att s√§ga. Antingen spelar den personen sitt spel bra, " +
  "eller s√• har den inget att d√∂lja. ü§î",
```

All Swedish text uses proper characters. Never substitute with a/a/o.
  </action>
  <verify>Run `npx tsc --noEmit` from the project root. All new types should be consistent with the Database type definition and existing patterns. No compilation errors.</verify>
  <done>schema.sql has anonymous_whispers and surveillance tables. types.ts exports AnonymousWhisper, Surveillance, and related types. client.ts exports createAnonymousWhisper, createSurveillance, getSurveillanceForPlayerInRound. messages.ts has all engagement template messages. TypeScript compiles without errors.</done>
</task>

<task type="auto">
  <name>Task 2: AI generation functions for whisper relay and surveillance clues</name>
  <files>src/lib/ai-prompts.ts, src/lib/ai-guzman.ts</files>
  <action>
1. **ai-prompts.ts** -- Add two new prompt builders:

`buildWhisperRelayPrompt(senderRole: PlayerRole, whisperText: string, gameContext: GuzmanContext): string`
- Instruct Guzman to relay an anonymous message to the group
- Include the sender's role as HEMLIGT context -- Guzman must give only a KRYPTISK LEDTRAD, never reveal the role
- Role hints should feel like Guzman's paranoid personality, not objective clues:
  - golare: "n√•gon som k√§nner lukten av para" (adapt freely)
  - hogra_hand: "n√•gon med skarpa √∂gon" (adapt freely)
  - akta: "n√•gon fr√•n familjen" (adapt freely)
- Instruct: present the message as something whispered to Guzman, add a subtle cryptic hint about the sender's role, keep Guzman tone, max 600 chars, use `<b>` and `<i>`

`buildSurveillanceCluePrompt(targetName: string, targetRole: PlayerRole, roundEvents: string, gameContext: GuzmanContext): string`
- Instruct Guzman to give a vague clue about the target based on their ACTIONS this round (not role directly)
- The clue should be action-based/behavior-based, not a role reveal
- Keep it cryptic and Guzman-flavored. Max 400 chars. Use `<b>` and `<i>`

Import `PlayerRole` from `../db/types.js`.

2. **ai-guzman.ts** -- Add two new generation functions:

`generateWhisperRelay(senderRole: PlayerRole, whisperText: string, gameContext: GuzmanContext): Promise<string>`
- Uses MODEL_MAP.narrative (gpt-4o-mini) for quality relay
- Falls back to MESSAGES.WHISPER_RELAY_TEMPLATE(whisperText) on failure
- Sanitizes output with sanitizeForTelegram
- Max 600 tokens, temperature 0.9

`generateSurveillanceClue(targetName: string, targetRole: PlayerRole, roundEvents: string, gameContext: GuzmanContext): Promise<string>`
- Uses MODEL_MAP.commentary (gpt-4.1-nano) for cost efficiency (clues are short)
- Falls back to MESSAGES.SURVEILLANCE_CLUE_TEMPLATE(targetName) on failure
- Sanitizes output with sanitizeForTelegram
- Max 300 tokens, temperature 0.9

Both functions follow the existing pattern: check getAIClient(), return template fallback if null, try/catch with console.warn on failure. Import PlayerRole from types.
  </action>
  <verify>Run `npx tsc --noEmit` from the project root. New functions should be properly exported and typed. No compilation errors.</verify>
  <done>ai-prompts.ts exports buildWhisperRelayPrompt and buildSurveillanceCluePrompt. ai-guzman.ts exports generateWhisperRelay and generateSurveillanceClue with template fallbacks. TypeScript compiles without errors.</done>
</task>

<task type="auto">
  <name>Task 3: Engagement handler (Composer) with /viska, /spana, and bot.ts registration</name>
  <files>src/handlers/engagement.ts, src/bot.ts</files>
  <action>
Create **src/handlers/engagement.ts** as a new Composer following the established pattern (see lobby.ts, game-commands.ts, game-loop.ts):

```typescript
import { Composer, InlineKeyboard } from "grammy";
// Import needed DB functions, AI functions, types, messages, queue
```

**In-memory state (same pattern as Sista Chansen):**
- `pendingWhispers: Map<number, PendingWhisper>` keyed by telegram_user_id
- PendingWhisper type: `{ gameId: string; gamePlayerId: string; groupChatId: number; senderRole: PlayerRole; target: "group" | { playerId: string; playerName: string }; createdAt: number }`
- `WHISPER_PENDING_TTL_MS = 5 * 60 * 1000` (5 minutes)

**Shared helper:** `getActiveGameContext(telegramUserId: number)` -- look up player by telegram ID (getPlayerByTelegramId), get their active game (getPlayerActiveGame), get current round (getCurrentRound), return `{ game, gamePlayer, round, players }` or null. This avoids code duplication across commands.

**Eligibility check helper:** `isNonTeamPlayer(gamePlayerId: string, round: Round): boolean` -- returns true if player is NOT in round.team_player_ids AND the game is in an active round (phase is mission_posted, nomination, voting, execution, or reveal). Return false if game state is not active or no active round.

**1. /viska command (DM only):**
- Use `.chatType("private").command("viska", ...)`
- Call getActiveGameContext. If null, reply ENGAGEMENT_NO_GAME
- Check game.state === "active" and round exists. If not, reply ENGAGEMENT_WRONG_PHASE
- Check isNonTeamPlayer. If on team, reply ENGAGEMENT_ON_TEAM
- Build inline keyboard with player names: "Till gruppen" button (callback: `wt:{gameId}:group`) plus one button per player (callback: `wt:{gameId}:p{index}` where index is position in players array). Exclude the sender from player list
- Reply with WHISPER_TARGET_PROMPT and keyboard

**2. Whisper target callback (wt:{gameId}:{target}):**
- Pattern: `/^wt:(.+):(group|p\d+)$/`
- Parse gameId and target from match
- If target is "group", set pending with target: "group"
- If target is "p{index}", resolve the player from the ordered players list, set pending with target: { playerId, playerName }
- Store in pendingWhispers Map with createdAt: Date.now()
- Reply with WHISPER_MESSAGE_PROMPT
- Answer callback query

**3. Freeform text handler (captures whisper content):**
- Use `.chatType("private").on("message:text", async (ctx, next) => { ... })`
- Check pendingWhispers.get(ctx.from.id). If none, call `await next()` and return
- Check TTL: if Date.now() - pending.createdAt > WHISPER_PENDING_TTL_MS, delete pending, reply WHISPER_EXPIRED, return
- Delete pending from Map immediately (before async work)
- Get round context (game, round via getGameById, getCurrentRound)
- Generate AI relay: call generateWhisperRelay(pending.senderRole, ctx.message.text, guzmanContext)
- Store in DB: createAnonymousWhisper with original_message and relayed_message
- If target is "group": send relayed message to pending.groupChatId via MessageQueue
- If target is a player: send via MessageQueue to that player's dm_chat_id (look up from getGamePlayersOrderedWithInfo)
- Reply to sender with WHISPER_SENT_CONFIRM

**4. /spana command (DM only):**
- Use `.chatType("private").command("spana", ...)`
- Call getActiveGameContext. If null, reply ENGAGEMENT_NO_GAME
- Check game.state === "active" and round exists and round.team_player_ids.length > 0. If no team, reply ENGAGEMENT_WRONG_PHASE
- Check isNonTeamPlayer. If on team, reply ENGAGEMENT_ON_TEAM
- Check getSurveillanceForPlayerInRound. If already used, reply SURVEILLANCE_ALREADY_USED
- Build inline keyboard with team member names only (from round.team_player_ids). Callback data: `sp:{gameId}:{roundNumber}:{index}` where index is team member position
- Reply with SURVEILLANCE_TARGET_PROMPT and keyboard

**5. Surveillance target callback (sp:{gameId}:{roundNumber}:{index}):**
- Pattern: `/^sp:(.+):(\d+):(\d+)$/`
- Parse gameId, roundNumber, and target index
- Re-verify: game active, player not on team, not already used this round (race condition check)
- Resolve target player from team_player_ids using index
- Get round events via the gatherRoundEvents pattern from whisper-handler.ts (copy or extract the helper)
- Generate AI clue: call generateSurveillanceClue(targetName, targetRole, roundEvents, guzmanContext)
- Determine notification: use `randomInt(0, 100) < 40` (40% chance, using node:crypto randomInt per established pattern)
- Store in DB: createSurveillance with clue_message and target_notified
- Send clue to surveiller's DM via reply (or MessageQueue)
- If target_notified: send SURVEILLANCE_TARGET_NOTIFIED to target player's dm_chat_id via MessageQueue (catch-and-log, non-blocking)
- Answer callback query with SURVEILLANCE_SENT_CONFIRM

**CRITICAL: Handler registration order in the Composer.** The freeform text handler MUST be the LAST handler in the Composer. Commands and callbacks are checked first by grammy, but the text handler uses `on("message:text")` which matches broadly. The `await next()` guard (checking pendingWhispers Map) ensures it only captures messages when a whisper is pending. Without this, it would eat all DM text messages.

**bot.ts changes:**
- Import `engagementHandler` from `./handlers/engagement.js`
- Register AFTER existing handlers: `bot.use(engagementHandler)` -- add this line after `bot.use(gameLoopHandler)` and before the scheduler section
- This ensures /viska and /spana don't interfere with existing DM commands (/start, /regler, /status), and the text handler's `await next()` passes through non-whisper messages
  </action>
  <verify>Run `npx tsc --noEmit` from the project root. The engagement handler should compile, be registered in bot.ts, and all imports resolve. No compilation errors.</verify>
  <done>engagement.ts is a working Composer with /viska (anonymous whisper flow: target selection -> freeform text capture -> AI relay to group), /spana (surveillance: target selection -> AI clue -> 40% notification). Registered in bot.ts after existing handlers. Pending whisper state uses in-memory Map with 5-minute TTL. All DB persistence works. TypeScript compiles without errors.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes -- all new files compile
2. Verify engagement handler is registered in bot.ts after gameLoopHandler
3. Verify schema.sql has both new tables with correct constraints
4. Verify types.ts Database type includes new tables
5. Verify client.ts exports all three new CRUD functions
6. Verify ai-guzman.ts exports generateWhisperRelay and generateSurveillanceClue
7. Verify messages.ts has all engagement template messages with proper Swedish characters
</verification>

<success_criteria>
- Non-team player can /viska in DM, select a target, type a message, and have Guzman relay it to the group with a role hint
- Non-team player can /spana in DM, select a team member, and receive a cryptic clue about them
- Surveillance is limited to once per round per player (UNIQUE constraint)
- 40% chance of target notification on surveillance
- All AI generation has template fallbacks
- Pending whisper state expires after 5 minutes
- All outbound group messages go through MessageQueue
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-engagement/05-01-SUMMARY.md`
</output>
