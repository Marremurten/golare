---
phase: 02-behavioral-analysis
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/types.ts
  - src/lib/behavioral-analysis.ts
  - src/lib/ai-guzman.ts
autonomous: true

must_haves:
  truths:
    - "After a round reveal, GuzmanContext.playerNotes contains a structured Swedish summary for each active player"
    - "Each player summary includes tone classification, activity level, relationship targeting, and anomaly flags"
    - "Inactive players get a minimal 'inaktiv' marker instead of a full summary"
    - "Anomaly detection compares against the player's own behavioral history across rounds"
    - "Total token budget for all playerNotes stays within ~500 tokens (CONST-02)"
  artifacts:
    - path: "src/lib/behavioral-analysis.ts"
      provides: "All behavioral analysis logic: stats, tone, anomalies, summaries, orchestrator"
      exports: ["analyzeBehavior"]
    - path: "src/db/types.ts"
      provides: "Extended GuzmanContext with optional behavioralHistory field"
      contains: "behavioralHistory"
    - path: "src/lib/ai-guzman.ts"
      provides: "updateNarrativeContext calls analyzeBehavior to populate playerNotes"
      contains: "analyzeBehavior"
  key_links:
    - from: "src/lib/ai-guzman.ts"
      to: "src/lib/behavioral-analysis.ts"
      via: "import and call analyzeBehavior(gameId) in updateNarrativeContext"
      pattern: "analyzeBehavior"
    - from: "src/lib/behavioral-analysis.ts"
      to: "src/db/client.ts"
      via: "getAllRecentMessages and getGamePlayersWithInfo for data"
      pattern: "getAllRecentMessages|getGamePlayersWithInfo"
    - from: "src/lib/behavioral-analysis.ts"
      to: "src/db/client.ts"
      via: "getGuzmanContext for behavioralHistory baseline"
      pattern: "getGuzmanContext"
---

<objective>
Create the behavioral analysis module and wire it into the narrative context update flow.

Purpose: Populate GuzmanContext.playerNotes with structured Swedish behavioral summaries so that downstream AI prompts (whispers, gap-fill, missions in Phases 3-5) have per-player behavioral context. This is the core intelligence layer for making Guzman reactive to real player behavior.

Output: One new module (behavioral-analysis.ts), one modified type (GuzmanContext), one modified function (updateNarrativeContext).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-behavioral-analysis/02-CONTEXT.md
@.planning/phases/02-behavioral-analysis/02-RESEARCH.md
@.planning/phases/01-data-pipeline/01-01-SUMMARY.md
@.planning/phases/01-data-pipeline/01-02-SUMMARY.md
@src/db/types.ts
@src/db/client.ts
@src/lib/ai-guzman.ts
@src/lib/ai-prompts.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create behavioral-analysis.ts module and extend GuzmanContext type</name>
  <files>src/lib/behavioral-analysis.ts, src/db/types.ts</files>
  <action>
**1. Extend GuzmanContext type in src/db/types.ts:**

Add an optional `behavioralHistory` field to the existing `GuzmanContext` type. This stores per-player stats snapshots per round for cross-round anomaly comparison. Keep it optional so existing code is unaffected:

```typescript
export type GuzmanContext = {
  storyArc: string;
  roundSummaries: Array<{
    round: number;
    missionTheme: string;
    outcome: "success" | "fail" | "kaos_fail";
    narrativeBeats: string;
  }>;
  playerNotes: Record<string, string>;
  mood: string;
  behavioralHistory?: Record<string, Array<{
    round: number;
    messageCount: number;
    avgLength: number;
    frequency: number;
    primaryTone: string;
  }>>;
};
```

**2. Create src/lib/behavioral-analysis.ts with these components:**

All internal types use `type` aliases (not `interface`) per project convention.

**Internal types:**
- `PlayerStats`: `{ messageCount: number; avgLength: number; timeSinceLastMsg: number | null; frequency: number; targetedPlayers: Map<string, number> }`
- `ToneLabel`: `"anklagande" | "defensiv" | "tyst" | "neutral" | "kaotisk"`
- `PlayerAnalysis`: `{ stats: PlayerStats; primaryTone: ToneLabel; secondaryTone: ToneLabel | null; anomalies: string[] }`

**Pure function: `computePlayerStats(messages: PlayerMessage[]): PlayerStats`**
- messageCount: messages.length
- avgLength: average of message_text.length (guard division by zero -- return 0 if no messages)
- timeSinceLastMsg: minutes since most recent message's sent_at to now. null if no messages.
- frequency: messages per hour based on time span from oldest to newest message. Guard: if only 1 message or all same timestamp, return 0.
- targetedPlayers: scan message_text for @username mentions (regex `@(\w+)`) and first_name mentions (case-insensitive substring match). Count mentions per player name. Only count mentions with threshold >= 2 to reduce noise. Use `normalize("NFC")` and `toLowerCase()` for Swedish character safety.

**Pure function: `classifyTone(messages: PlayerMessage[]): { primary: ToneLabel; secondary: ToneLabel | null }`**
- Use heuristic Swedish keyword matching. Build keyword maps for each tone:
  - `anklagande` (accusatory): "golare", "gola", "misstänker", "litar inte", "suspekt", "råtta", "förrädare", "ljuger", "snitch", "sus", "cap", "fake", "snitcha"
  - `defensiv` (defensive): "oskyld", "inte jag", "litar på mig", "lovar", "svär", "wallah det var inte", "jag svär", "det var inte jag", "tro mig"
  - `kaotisk` (chaotic): "haha", "lol", "yolo", "skiter i", "kör", "yalla kör", "asså bre", "wallah", "bre va fan"
  - `neutral`: no strong signals or balanced across categories
  - `tyst`: 0-1 messages -- override to "tyst" regardless of content
- Normalize each message with `normalize("NFC")` + `toLowerCase()` before matching.
- Score: count keyword hits per tone. Highest score = primary. Second highest (if >= 2 hits) = secondary.
- If 0-1 messages total, force primary = "tyst", secondary = null.
- If no keywords match in any category, primary = "neutral", secondary = null.

**Pure function: `detectAnomalies(currentStats: PlayerStats, currentTone: ToneLabel, history: Array<{ round: number; messageCount: number; avgLength: number; frequency: number; primaryTone: string }> | undefined): string[]`**
- Anomaly baseline is relative to the player's own history (locked decision).
- Track across rounds (locked decision).
- If no history (first round), return empty array -- no baseline to compare.
- Detection rules:
  1. **Suspicious silence:** If player had >= 3 messages in any previous round but now has 0-1, add "tystnat plotsligt" (gone suddenly quiet).
  2. **Aggression spike:** If current tone is "anklagande" but previous rounds were mostly "neutral" or "defensiv", add "aggressionsökning" (aggression spike).
  3. **Activity drop:** If current frequency is less than 30% of average historical frequency (and history has >= 2 entries), add "aktivitet sjunkit" (activity dropped).
  4. **Behavior shift:** If current tone differs from the most common historical tone (mode), add "beteendeförändring" (behavior shift). Only trigger if history has >= 2 entries with same tone.
- Return array of anomaly strings (in Swedish). Empty array = no anomalies.

**Pure function: `buildPlayerSummary(name: string, analysis: PlayerAnalysis): string`**
- Format: structured labels per locked decision. Example: `Ton: defensiv | Aktivitet: hög | Riktar sig mot: Kansen | Anomali: ingen`
- Components:
  - `Ton:` primary tone. If secondary exists, format as `Ton: defensiv/kaotisk`
  - `Aktivitet:` map messageCount to label: 0 = "ingen", 1-2 = "låg", 3-5 = "medel", 6+ = "hög"
  - `Riktar sig mot:` top targeted player name from stats.targetedPlayers (most mentions). Omit if no player has >= 2 mentions.
  - `Anomali:` join anomalies with ", " or "ingen" if empty.
- If messageCount is 0, return just "inaktiv" (locked decision for inactive players).
- Hard-cap summary string at 200 characters (truncate with "..." if needed) to respect token budget.

**Main orchestrator: `async function analyzeBehavior(gameId: string): Promise<{ playerNotes: Record<string, string>; historyUpdate: Record<string, Array<{ round: number; messageCount: number; avgLength: number; frequency: number; primaryTone: string }>> }>`**
- Import and call `getAllRecentMessages(gameId)` to get all messages.
- Import and call `getGamePlayersWithInfo(gameId)` to resolve player names (use `first_name || username || "Spelare"` as display name, matching existing codebase pattern).
- Import and call `getGuzmanContext(gameId)` to get existing `behavioralHistory` for anomaly baseline.
- Group messages by `game_player_id`.
- For each game_player:
  - Get their messages (or empty array if none).
  - Build a name->game_player_id mapping for relationship detection (pass all player names to stats computation).
  - Compute stats, classify tone, detect anomalies (passing history from behavioralHistory).
  - Build summary string.
- Build `playerNotes: Record<string, string>` keyed by display name (matching existing playerNotes convention).
- Build `historyUpdate` with current round's stats appended to existing history for each player.
- Return both playerNotes and historyUpdate.

**CRITICAL constraints:**
- Zero new npm dependencies (CONST-01).
- All Swedish text uses proper characters (never substitute a/a/o for swedish chars).
- Use `type` aliases, not `interface` (project convention).
- Use ESM imports with `.js` extensions (NodeNext resolution).
- All keyword lists in Swedish with correct characters.
  </action>
  <verify>
Run `npx tsc --noEmit` -- should compile with zero errors. Verify behavioral-analysis.ts exports `analyzeBehavior`. Verify GuzmanContext type in types.ts has optional `behavioralHistory` field.
  </verify>
  <done>
behavioral-analysis.ts exists with all pure functions (computePlayerStats, classifyTone, detectAnomalies, buildPlayerSummary) and the analyzeBehavior orchestrator. GuzmanContext type extended with optional behavioralHistory. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire analyzeBehavior into updateNarrativeContext</name>
  <files>src/lib/ai-guzman.ts</files>
  <action>
**Modify `updateNarrativeContext()` in src/lib/ai-guzman.ts to call `analyzeBehavior()`.**

Add import at top of file:
```typescript
import { analyzeBehavior } from "./behavioral-analysis.js";
```

In the `updateNarrativeContext` function, after the existing logic (round summary append, mood update, story arc, compression) but BEFORE the final `await dbUpdateGuzmanContext(gameId, context)` call, add:

```typescript
// Populate playerNotes with behavioral analysis (non-critical)
try {
  const { playerNotes, historyUpdate } = await analyzeBehavior(gameId);
  context.playerNotes = playerNotes;
  context.behavioralHistory = historyUpdate;
} catch (err) {
  console.warn(
    "[ai-guzman] Behavioral analysis failed, playerNotes unchanged:",
    err instanceof Error ? err.message : err,
  );
  // Non-critical: if analysis fails, playerNotes stays as-is (empty or stale)
  // Game continues normally -- CONST-04 pattern
}
```

This follows the existing error handling pattern in the codebase: try/catch with console.warn, non-blocking. The behavioralHistory is persisted alongside playerNotes in the same `dbUpdateGuzmanContext` call that already exists at the end of the function -- no additional DB write needed.

**Why this placement works:**
- `updateNarrativeContext` is called after every round reveal (game-loop.ts lines 620 and 741).
- It already writes to guzman_context JSONB via `dbUpdateGuzmanContext`.
- The `behavioralHistory` field is optional on the GuzmanContext type, so existing contexts without it work fine.
- The try/catch ensures behavioral analysis failure never blocks the game loop (CONST-04).

**Do NOT modify:**
- game-loop.ts (no changes needed -- it already calls updateNarrativeContext)
- ai-prompts.ts (already reads playerNotes at line 150 -- no changes needed)
- db/client.ts (already handles GuzmanContext as Record<string, unknown> via type cast)
  </action>
  <verify>
Run `npx tsc --noEmit` -- should compile with zero errors. Grep for `analyzeBehavior` in ai-guzman.ts to confirm it is imported and called within updateNarrativeContext. Verify the try/catch wrapping matches CONST-04 pattern.
  </verify>
  <done>
updateNarrativeContext in ai-guzman.ts calls analyzeBehavior(gameId) to populate playerNotes and behavioralHistory on every round reveal. Failure is caught and logged without blocking the game. TypeScript compiles cleanly. The existing buildWhisperPrompt (ai-prompts.ts line 150) will automatically receive behavioral summaries via `gameContext.playerNotes[targetPlayerName]`.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `grep -n "analyzeBehavior" src/lib/ai-guzman.ts` shows import and call within updateNarrativeContext
3. `grep -n "behavioralHistory" src/db/types.ts` shows the optional field on GuzmanContext
4. `grep -n "export.*analyzeBehavior" src/lib/behavioral-analysis.ts` shows the exported orchestrator
5. `grep -rn "playerNotes" src/lib/ai-prompts.ts` confirms existing whisper prompt reads playerNotes (no changes needed)
6. No new entries in package.json dependencies (CONST-01)
</verification>

<success_criteria>
- behavioral-analysis.ts exists with pure functions for stats, tone, anomalies, and summaries
- GuzmanContext extended with optional behavioralHistory for cross-round tracking
- updateNarrativeContext calls analyzeBehavior and populates playerNotes + behavioralHistory
- All Swedish text uses proper characters
- Tone classification uses 5 categories: anklagande, defensiv, tyst, neutral, kaotisk
- Summary format is structured labels: "Ton: X | Aktivitet: Y | Riktar sig mot: Z | Anomali: W"
- Inactive players get just "inaktiv" marker
- Anomaly detection is relative to player's own history across rounds
- Token budget stays within CONST-02 (~50 per player, hard-cap 200 chars per summary)
- Zero new npm dependencies
- TypeScript compiles with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-behavioral-analysis/02-01-SUMMARY.md`
</output>
